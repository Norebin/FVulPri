CVEid,func,expert
CVE-2019-1010293,"TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,
				       uint32_t flags, uaddr_t uaddr,
 				       size_t len)
 {
 	uaddr_t a;
 	size_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,
 			       CORE_MMU_USER_PARAM_SIZE);
 
	if (ADD_OVERFLOW(uaddr, len, &a))
 		return TEE_ERROR_ACCESS_DENIED;
 
 	if ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&
	    (flags & TEE_MEMORY_ACCESS_SECURE))
		return TEE_ERROR_ACCESS_DENIED;

	/*
	 * Rely on TA private memory test to check if address range is private
	 * to TA or not.
	 */
	if (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&
 	   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))
 		return TEE_ERROR_ACCESS_DENIED;
 
	for (a = uaddr; a < (uaddr + len); a += addr_incr) {
 		uint32_t attr;
 		TEE_Result res;
 
		res = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);
		if (res != TEE_SUCCESS)
			return res;

		if ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&
		    (attr & TEE_MATTR_SECURE))
			return TEE_ERROR_ACCESS_DENIED;

		if ((flags & TEE_MEMORY_ACCESS_SECURE) &&
		    !(attr & TEE_MATTR_SECURE))
			return TEE_ERROR_ACCESS_DENIED;

		if ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))
			return TEE_ERROR_ACCESS_DENIED;
		if ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))
			return TEE_ERROR_ACCESS_DENIED;
	}

	return TEE_SUCCESS;
}
",agree
CVE-2011-2839,"void CrosMock::SetSpeechSynthesisLibraryExpectations() {
  InSequence s;
   EXPECT_CALL(*mock_speech_synthesis_library_, StopSpeaking())
       .WillOnce(Return(true))
       .RetiresOnSaturation();
   EXPECT_CALL(*mock_speech_synthesis_library_, Speak(_))
       .WillOnce(Return(true))
       .RetiresOnSaturation();
   EXPECT_CALL(*mock_speech_synthesis_library_, IsSpeaking())
      .Times(AnyNumber())
      .WillRepeatedly(Return(true));
   EXPECT_CALL(*mock_speech_synthesis_library_, StopSpeaking())
       .WillOnce(Return(true))
       .RetiresOnSaturation();
   EXPECT_CALL(*mock_speech_synthesis_library_, Speak(_))
       .WillOnce(Return(true))
       .RetiresOnSaturation();
  EXPECT_CALL(*mock_speech_synthesis_library_, IsSpeaking())
      .WillOnce(Return(true))
      .WillOnce(Return(true))
      .WillOnce(Return(false))
      .RetiresOnSaturation();
}
",agree
CVE-2017-14604,"copy_move_file (CopyMoveJob   *copy_job,
                GFile         *src,
                GFile         *dest_dir,
                gboolean       same_fs,
                gboolean       unique_names,
                char         **dest_fs_type,
                SourceInfo    *source_info,
                TransferInfo  *transfer_info,
                GHashTable    *debuting_files,
                GdkPoint      *position,
                gboolean       overwrite,
                gboolean      *skipped_file,
                gboolean       readonly_source_fs)
{
    GFile *dest, *new_dest;
    g_autofree gchar *dest_uri = NULL;
    GError *error;
    GFileCopyFlags flags;
    char *primary, *secondary, *details;
    int response;
    ProgressData pdata;
    gboolean would_recurse, is_merge;
    CommonJob *job;
    gboolean res;
    int unique_name_nr;
    gboolean handled_invalid_filename;

    job = (CommonJob *) copy_job;

    if (should_skip_file (job, src))
    {
        *skipped_file = TRUE;
        return;
    }

    unique_name_nr = 1;

    /* another file in the same directory might have handled the invalid
     * filename condition for us
     */
    handled_invalid_filename = *dest_fs_type != NULL;

    if (unique_names)
    {
        dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr++);
    }
    else if (copy_job->target_name != NULL)
    {
        dest = get_target_file_with_custom_name (src, dest_dir, *dest_fs_type, same_fs,
                                                 copy_job->target_name);
    }
    else
    {
        dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);
    }

    /* Don't allow recursive move/copy into itself.
     * (We would get a file system error if we proceeded but it is nicer to
     * detect and report it at this level) */
    if (test_dir_is_parent (dest_dir, src))
    {
        if (job->skip_all_error)
        {
            goto out;
        }

        /*  the run_warning() frees all strings passed in automatically  */
        primary = copy_job->is_move ? g_strdup (_(""You cannot move a folder into itself.""))
                  : g_strdup (_(""You cannot copy a folder into itself.""));
        secondary = g_strdup (_(""The destination folder is inside the source folder.""));

        response = run_cancel_or_skip_warning (job,
                                               primary,
                                               secondary,
                                               NULL,
                                               source_info->num_files,
                                               source_info->num_files - transfer_info->num_files);

        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
        {
            abort_job (job);
        }
        else if (response == 1)             /* skip all */
        {
            job->skip_all_error = TRUE;
        }
        else if (response == 2)             /* skip */
        {               /* do nothing */
        }
        else
        {
            g_assert_not_reached ();
        }

        goto out;
    }

    /* Don't allow copying over the source or one of the parents of the source.
     */
    if (test_dir_is_parent (src, dest))
    {
        if (job->skip_all_error)
        {
            goto out;
        }

        /*  the run_warning() frees all strings passed in automatically  */
        primary = copy_job->is_move ? g_strdup (_(""You cannot move a file over itself.""))
                  : g_strdup (_(""You cannot copy a file over itself.""));
        secondary = g_strdup (_(""The source file would be overwritten by the destination.""));

        response = run_cancel_or_skip_warning (job,
                                               primary,
                                               secondary,
                                               NULL,
                                               source_info->num_files,
                                               source_info->num_files - transfer_info->num_files);

        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
        {
            abort_job (job);
        }
        else if (response == 1)             /* skip all */
        {
            job->skip_all_error = TRUE;
        }
        else if (response == 2)             /* skip */
        {               /* do nothing */
        }
        else
        {
            g_assert_not_reached ();
        }

        goto out;
    }


retry:

    error = NULL;
    flags = G_FILE_COPY_NOFOLLOW_SYMLINKS;
    if (overwrite)
    {
        flags |= G_FILE_COPY_OVERWRITE;
    }
    if (readonly_source_fs)
    {
        flags |= G_FILE_COPY_TARGET_DEFAULT_PERMS;
    }

    pdata.job = copy_job;
    pdata.last_size = 0;
    pdata.source_info = source_info;
    pdata.transfer_info = transfer_info;

    if (copy_job->is_move)
    {
        res = g_file_move (src, dest,
                           flags,
                           job->cancellable,
                           copy_file_progress_callback,
                           &pdata,
                           &error);
    }
    else
    {
        res = g_file_copy (src, dest,
                           flags,
                           job->cancellable,
                           copy_file_progress_callback,
                           &pdata,
                           &error);
    }

    if (res)
    {
        GFile *real;

        real = map_possibly_volatile_file_to_real (dest, job->cancellable, &error);
        if (real == NULL)
        {
            res = FALSE;
        }
        else
        {
            g_object_unref (dest);
            dest = real;
        }
    }

    if (res)
    {
        transfer_info->num_files++;
        report_copy_progress (copy_job, source_info, transfer_info);

        if (debuting_files)
        {
            dest_uri = g_file_get_uri (dest);
            if (position)
            {
                nautilus_file_changes_queue_schedule_position_set (dest, *position, job->screen_num);
            }
            else if (eel_uri_is_desktop (dest_uri))
            {
                nautilus_file_changes_queue_schedule_position_remove (dest);
            }

            g_hash_table_replace (debuting_files, g_object_ref (dest), GINT_TO_POINTER (TRUE));
        }
        if (copy_job->is_move)
        {
            nautilus_file_changes_queue_file_moved (src, dest);
        }
        else
        {
            nautilus_file_changes_queue_file_added (dest);
        }

        /* If copying a trusted desktop file to the desktop,
         *  mark it as trusted. */
        if (copy_job->desktop_location != NULL &&
             g_file_equal (copy_job->desktop_location, dest_dir) &&
             is_trusted_desktop_file (src, job->cancellable))
         {
            mark_desktop_file_trusted (job,
                                       job->cancellable,
                                       dest,
                                       FALSE);
         }
 
         if (job->undo_info != NULL)
        {
            nautilus_file_undo_info_ext_add_origin_target_pair (NAUTILUS_FILE_UNDO_INFO_EXT (job->undo_info),
                                                                src, dest);
        }

        g_object_unref (dest);
        return;
    }

    if (!handled_invalid_filename &&
        IS_IO_ERROR (error, INVALID_FILENAME))
    {
        handled_invalid_filename = TRUE;

        g_assert (*dest_fs_type == NULL);
        *dest_fs_type = query_fs_type (dest_dir, job->cancellable);

        if (unique_names)
        {
            new_dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr);
        }
        else
        {
            new_dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs);
        }

        if (!g_file_equal (dest, new_dest))
        {
            g_object_unref (dest);
            dest = new_dest;

            g_error_free (error);
            goto retry;
        }
        else
        {
            g_object_unref (new_dest);
        }
    }

    /* Conflict */
    if (!overwrite &&
        IS_IO_ERROR (error, EXISTS))
    {
        gboolean is_merge;
        FileConflictResponse *response;

        g_error_free (error);

        if (unique_names)
        {
            g_object_unref (dest);
            dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr++);
            goto retry;
        }

        is_merge = FALSE;

        if (is_dir (dest) && is_dir (src))
        {
            is_merge = TRUE;
        }

        if ((is_merge && job->merge_all) ||
            (!is_merge && job->replace_all))
        {
            overwrite = TRUE;
            goto retry;
        }

        if (job->skip_all_conflict)
        {
            goto out;
        }

        response = handle_copy_move_conflict (job, src, dest, dest_dir);

        if (response->id == GTK_RESPONSE_CANCEL ||
            response->id == GTK_RESPONSE_DELETE_EVENT)
        {
            file_conflict_response_free (response);
            abort_job (job);
        }
        else if (response->id == CONFLICT_RESPONSE_SKIP)
        {
            if (response->apply_to_all)
            {
                job->skip_all_conflict = TRUE;
            }
            file_conflict_response_free (response);
        }
        else if (response->id == CONFLICT_RESPONSE_REPLACE)             /* merge/replace */
        {
            if (response->apply_to_all)
            {
                if (is_merge)
                {
                    job->merge_all = TRUE;
                }
                else
                {
                    job->replace_all = TRUE;
                }
            }
            overwrite = TRUE;
            file_conflict_response_free (response);
            goto retry;
        }
        else if (response->id == CONFLICT_RESPONSE_RENAME)
        {
            g_object_unref (dest);
            dest = get_target_file_for_display_name (dest_dir,
                                                     response->new_name);
            file_conflict_response_free (response);
            goto retry;
        }
        else
        {
            g_assert_not_reached ();
        }
    }
    else if (overwrite &&
             IS_IO_ERROR (error, IS_DIRECTORY))
    {
        gboolean existing_file_deleted;
        DeleteExistingFileData data;

        g_error_free (error);

        data.job = job;
        data.source = src;

        existing_file_deleted =
            delete_file_recursively (dest,
                                     job->cancellable,
                                     existing_file_removed_callback,
                                     &data);

        if (existing_file_deleted)
        {
            goto retry;
        }
    }
    /* Needs to recurse */
    else if (IS_IO_ERROR (error, WOULD_RECURSE) ||
             IS_IO_ERROR (error, WOULD_MERGE))
    {
        is_merge = error->code == G_IO_ERROR_WOULD_MERGE;
        would_recurse = error->code == G_IO_ERROR_WOULD_RECURSE;
        g_error_free (error);

        if (overwrite && would_recurse)
        {
            error = NULL;

            /* Copying a dir onto file, first remove the file */
            if (!g_file_delete (dest, job->cancellable, &error) &&
                !IS_IO_ERROR (error, NOT_FOUND))
            {
                if (job->skip_all_error)
                {
                    g_error_free (error);
                    goto out;
                }
                if (copy_job->is_move)
                {
                    primary = f (_(""Error while moving “%B”.""), src);
                }
                else
                {
                    primary = f (_(""Error while copying “%B”.""), src);
                }
                secondary = f (_(""Could not remove the already existing file with the same name in %F.""), dest_dir);
                details = error->message;

                /* setting TRUE on show_all here, as we could have
                 * another error on the same file later.
                 */
                response = run_warning (job,
                                        primary,
                                        secondary,
                                        details,
                                        TRUE,
                                        CANCEL, SKIP_ALL, SKIP,
                                        NULL);

                g_error_free (error);

                if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
                {
                    abort_job (job);
                }
                else if (response == 1)                     /* skip all */
                {
                    job->skip_all_error = TRUE;
                }
                else if (response == 2)                     /* skip */
                {                       /* do nothing */
                }
                else
                {
                    g_assert_not_reached ();
                }
                goto out;
            }
            if (error)
            {
                g_error_free (error);
                error = NULL;
            }
            nautilus_file_changes_queue_file_removed (dest);
        }

        if (is_merge)
        {
            /* On merge we now write in the target directory, which may not
             *   be in the same directory as the source, even if the parent is
             *   (if the merged directory is a mountpoint). This could cause
             *   problems as we then don't transcode filenames.
             *   We just set same_fs to FALSE which is safe but a bit slower. */
            same_fs = FALSE;
        }

        if (!copy_move_directory (copy_job, src, &dest, same_fs,
                                  would_recurse, dest_fs_type,
                                  source_info, transfer_info,
                                  debuting_files, skipped_file,
                                  readonly_source_fs))
        {
            /* destination changed, since it was an invalid file name */
            g_assert (*dest_fs_type != NULL);
            handled_invalid_filename = TRUE;
            goto retry;
        }

        g_object_unref (dest);
        return;
    }
    else if (IS_IO_ERROR (error, CANCELLED))
    {
        g_error_free (error);
    }
    /* Other error */
    else
    {
        if (job->skip_all_error)
        {
            g_error_free (error);
            goto out;
        }
        primary = f (_(""Error while copying “%B”.""), src);
        secondary = f (_(""There was an error copying the file into %F.""), dest_dir);
        details = error->message;

        response = run_cancel_or_skip_warning (job,
                                               primary,
                                               secondary,
                                               details,
                                               source_info->num_files,
                                               source_info->num_files - transfer_info->num_files);

        g_error_free (error);

        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
        {
            abort_job (job);
        }
        else if (response == 1)             /* skip all */
        {
            job->skip_all_error = TRUE;
        }
        else if (response == 2)             /* skip */
        {               /* do nothing */
        }
        else
        {
            g_assert_not_reached ();
        }
    }
out:
    *skipped_file = TRUE;     /* Or aborted, but same-same */
    g_object_unref (dest);
}
",neutral
CVE-2016-2464,"void Cues::Init() const {
   if (m_cue_points)
    return;
 
  assert(m_count == 0);
  assert(m_preload_count == 0);
 
   IMkvReader* const pReader = m_pSegment->m_pReader;
 
 const long long stop = m_start + m_size;
 long long pos = m_start;

 long cue_points_size = 0;

 while (pos < stop) {
 const long long idpos = pos;

 
     long len;
 
    const long long id = ReadUInt(pReader, pos, len);
    assert(id >= 0);  // TODO
    assert((pos + len) <= stop);
 
     pos += len;  // consume ID
 
     const long long size = ReadUInt(pReader, pos, len);
    assert(size >= 0);
    assert((pos + len) <= stop);
 
     pos += len;  // consume Size field
    assert((pos + size) <= stop);
 
    if (id == 0x3B)  // CuePoint ID
      PreloadCuePoint(cue_points_size, idpos);
 
    pos += size;  // consume payload
    assert(pos <= stop);
   }
 }
",neutral
CVE-2013-7271,"int bt_sock_stream_recvmsg(struct kiocb *iocb, struct socket *sock,
			       struct msghdr *msg, size_t size, int flags)
{
	struct sock *sk = sock->sk;
	int err = 0;
	size_t target, copied = 0;
	long timeo;

 	if (flags & MSG_OOB)
 		return -EOPNOTSUPP;
 
	msg->msg_namelen = 0;
 	BT_DBG(""sk %p size %zu"", sk, size);
 
 	lock_sock(sk);

	target = sock_rcvlowat(sk, flags & MSG_WAITALL, size);
	timeo  = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);

	do {
		struct sk_buff *skb;
		int chunk;

		skb = skb_dequeue(&sk->sk_receive_queue);
		if (!skb) {
			if (copied >= target)
				break;

			err = sock_error(sk);
			if (err)
				break;
			if (sk->sk_shutdown & RCV_SHUTDOWN)
				break;

			err = -EAGAIN;
			if (!timeo)
				break;

			timeo = bt_sock_data_wait(sk, timeo);

			if (signal_pending(current)) {
				err = sock_intr_errno(timeo);
				goto out;
			}
			continue;
		}

		chunk = min_t(unsigned int, skb->len, size);
		if (skb_copy_datagram_iovec(skb, 0, msg->msg_iov, chunk)) {
			skb_queue_head(&sk->sk_receive_queue, skb);
			if (!copied)
				copied = -EFAULT;
			break;
		}
		copied += chunk;
		size   -= chunk;

		sock_recv_ts_and_drops(msg, sk, skb);

		if (!(flags & MSG_PEEK)) {
			int skb_len = skb_headlen(skb);

			if (chunk <= skb_len) {
				__skb_pull(skb, chunk);
			} else {
				struct sk_buff *frag;

				__skb_pull(skb, skb_len);
				chunk -= skb_len;

				skb_walk_frags(skb, frag) {
					if (chunk <= frag->len) {
						/* Pulling partial data */
						skb->len -= chunk;
						skb->data_len -= chunk;
						__skb_pull(frag, chunk);
						break;
					} else if (frag->len) {
						/* Pulling all frag data */
						chunk -= frag->len;
						skb->len -= frag->len;
						skb->data_len -= frag->len;
						__skb_pull(frag, frag->len);
					}
				}
			}

			if (skb->len) {
				skb_queue_head(&sk->sk_receive_queue, skb);
				break;
			}
			kfree_skb(skb);

		} else {
			/* put message back and return */
			skb_queue_head(&sk->sk_receive_queue, skb);
			break;
		}
	} while (size);

out:
	release_sock(sk);
	return copied ? : err;
}
",agree
CVE-2017-11450,"static Image *ReadJPEGImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  char
    value[MaxTextExtent];

  const char
    *option;

  ErrorManager
    error_manager;

  Image
    *image;

  IndexPacket
    index;

  JSAMPLE
    *volatile jpeg_pixels;

  JSAMPROW
    scanline[1];

  MagickBooleanType
    debug,
    status;

  MagickSizeType
    number_pixels;

  MemoryInfo
    *memory_info;

  register ssize_t
    i;

  struct jpeg_decompress_struct
    jpeg_info;

  struct jpeg_error_mgr
    jpeg_error;

  register JSAMPLE
    *p;

  size_t
    units;

  ssize_t
    y;

  /*
    Open image file.
  */
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  debug=IsEventLogging();
  (void) debug;
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
   /*
     Initialize JPEG parameters.
   */
  (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));
  (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));
  (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));
  jpeg_info.err=jpeg_std_error(&jpeg_error);
  jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;
  jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;
  memory_info=(MemoryInfo *) NULL;
  error_manager.image=image;
  if (setjmp(error_manager.error_recovery) != 0)
    {
      jpeg_destroy_decompress(&jpeg_info);
      if (error_manager.profile != (StringInfo *) NULL)
        error_manager.profile=DestroyStringInfo(error_manager.profile);
      (void) CloseBlob(image);
      number_pixels=(MagickSizeType) image->columns*image->rows;
      if (number_pixels != 0)
        return(GetFirstImageInList(image));
      InheritException(exception,&image->exception);
      return(DestroyImage(image));
    }
  jpeg_info.client_data=(void *) &error_manager;
  jpeg_create_decompress(&jpeg_info);
  JPEGSourceManager(&jpeg_info,image);
  jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);
  option=GetImageOption(image_info,""profile:skip"");
  if (IsOptionMember(""ICC"",option) == MagickFalse)
    jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);
  if (IsOptionMember(""IPTC"",option) == MagickFalse)
    jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);
  for (i=1; i < 16; i++)
    if ((i != 2) && (i != 13) && (i != 14))
      if (IsOptionMember(""APP"",option) == MagickFalse)
        jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);
  i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);
  if ((image_info->colorspace == YCbCrColorspace) ||
      (image_info->colorspace == Rec601YCbCrColorspace) ||
      (image_info->colorspace == Rec709YCbCrColorspace))
    jpeg_info.out_color_space=JCS_YCbCr;
  /*
    Set image resolution.
  */
  units=0;
  if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&
      (jpeg_info.Y_density != 1))
    {
      image->x_resolution=(double) jpeg_info.X_density;
      image->y_resolution=(double) jpeg_info.Y_density;
      units=(size_t) jpeg_info.density_unit;
    }
  if (units == 1)
    image->units=PixelsPerInchResolution;
  if (units == 2)
    image->units=PixelsPerCentimeterResolution;
  number_pixels=(MagickSizeType) image->columns*image->rows;
  option=GetImageOption(image_info,""jpeg:size"");
  if ((option != (const char *) NULL) &&
      (jpeg_info.out_color_space != JCS_YCbCr))
    {
      double
        scale_factor;

      GeometryInfo
        geometry_info;

      MagickStatusType
        flags;

      /*
        Scale the image.
      */
      flags=ParseGeometry(option,&geometry_info);
      if ((flags & SigmaValue) == 0)
        geometry_info.sigma=geometry_info.rho;
      jpeg_calc_output_dimensions(&jpeg_info);
      image->magick_columns=jpeg_info.output_width;
      image->magick_rows=jpeg_info.output_height;
      scale_factor=1.0;
      if (geometry_info.rho != 0.0)
        scale_factor=jpeg_info.output_width/geometry_info.rho;
      if ((geometry_info.sigma != 0.0) &&
          (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))
        scale_factor=jpeg_info.output_height/geometry_info.sigma;
      jpeg_info.scale_num=1U;
      jpeg_info.scale_denom=(unsigned int) scale_factor;
      jpeg_calc_output_dimensions(&jpeg_info);
      if (image->debug != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Scale factor: %.20g"",(double) scale_factor);
    }
#if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)
#if defined(D_LOSSLESS_SUPPORTED)
  image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?
    JPEGInterlace : NoInterlace;
  image->compression=jpeg_info.process == JPROC_LOSSLESS ?
    LosslessJPEGCompression : JPEGCompression;
  if (jpeg_info.data_precision > 8)
    (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
      ""12-bit JPEG not supported. Reducing pixel data to 8 bits"",""`%s'"",
      image->filename);
  if (jpeg_info.data_precision == 16)
    jpeg_info.data_precision=12;
#else
  image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :
    NoInterlace;
  image->compression=JPEGCompression;
#endif
#else
  image->compression=JPEGCompression;
  image->interlace=JPEGInterlace;
#endif
  option=GetImageOption(image_info,""jpeg:colors"");
  if (option != (const char *) NULL)
    {
      /*
        Let the JPEG library quantize for us.
      */
      jpeg_info.quantize_colors=TRUE;
      jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);
    }
  option=GetImageOption(image_info,""jpeg:block-smoothing"");
  if (option != (const char *) NULL)
    jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :
      FALSE;
  jpeg_info.dct_method=JDCT_FLOAT;
  option=GetImageOption(image_info,""jpeg:dct-method"");
  if (option != (const char *) NULL)
    switch (*option)
    {
      case 'D':
      case 'd':
      {
        if (LocaleCompare(option,""default"") == 0)
          jpeg_info.dct_method=JDCT_DEFAULT;
        break;
      }
      case 'F':
      case 'f':
      {
        if (LocaleCompare(option,""fastest"") == 0)
          jpeg_info.dct_method=JDCT_FASTEST;
        if (LocaleCompare(option,""float"") == 0)
          jpeg_info.dct_method=JDCT_FLOAT;
        break;
      }
      case 'I':
      case 'i':
      {
        if (LocaleCompare(option,""ifast"") == 0)
          jpeg_info.dct_method=JDCT_IFAST;
        if (LocaleCompare(option,""islow"") == 0)
          jpeg_info.dct_method=JDCT_ISLOW;
        break;
      }
    }
  option=GetImageOption(image_info,""jpeg:fancy-upsampling"");
  if (option != (const char *) NULL)
    jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :
      FALSE;
  (void) jpeg_start_decompress(&jpeg_info);
  image->columns=jpeg_info.output_width;
  image->rows=jpeg_info.output_height;
  image->depth=(size_t) jpeg_info.data_precision;
  switch (jpeg_info.out_color_space)
  {
    case JCS_RGB:
    default:
    {
      (void) SetImageColorspace(image,sRGBColorspace);
      break;
    }
    case JCS_GRAYSCALE:
    {
      (void) SetImageColorspace(image,GRAYColorspace);
      break;
    }
    case JCS_YCbCr:
    {
      (void) SetImageColorspace(image,YCbCrColorspace);
      break;
    }
    case JCS_CMYK:
    {
      (void) SetImageColorspace(image,CMYKColorspace);
      break;
    }
  }
  if (IsITUFaxImage(image) != MagickFalse)
    {
      (void) SetImageColorspace(image,LabColorspace);
      jpeg_info.out_color_space=JCS_YCbCr;
    }
  option=GetImageOption(image_info,""jpeg:colors"");
  if (option != (const char *) NULL)
    if (AcquireImageColormap(image,StringToUnsignedLong(option)) == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
  if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))
    {
      size_t
        colors;

      colors=(size_t) GetQuantumRange(image->depth)+1;
      if (AcquireImageColormap(image,colors) == MagickFalse)
        {
          InheritException(exception,&image->exception);
          return(DestroyImageList(image));
        }
    }
  if (image->debug != MagickFalse)
    {
      if (image->interlace != NoInterlace)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Interlace: progressive"");
      else
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""Interlace: nonprogressive"");
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Data precision: %d"",
        (int) jpeg_info.data_precision);
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Geometry: %dx%d"",
        (int) jpeg_info.output_width,(int) jpeg_info.output_height);
    }
  JPEGSetImageQuality(&jpeg_info,image);
  JPEGSetImageSamplingFactor(&jpeg_info,image);
  (void) FormatLocaleString(value,MaxTextExtent,""%.20g"",(double)
    jpeg_info.out_color_space);
  (void) SetImageProperty(image,""jpeg:colorspace"",value);
  if (image_info->ping != MagickFalse)
    {
      jpeg_destroy_decompress(&jpeg_info);
      (void) CloseBlob(image);
      return(GetFirstImageInList(image));
    }
  status=SetImageExtent(image,image->columns,image->rows);
  if (status == MagickFalse)
    {
      jpeg_destroy_decompress(&jpeg_info);
      InheritException(exception,&image->exception);
      return(DestroyImageList(image));
    }
  if ((jpeg_info.output_components != 1) &&
      (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))
    {
      jpeg_destroy_decompress(&jpeg_info);
      ThrowReaderException(CorruptImageError,""ImageTypeNotSupported"");
    }
  memory_info=AcquireVirtualMemory((size_t) image->columns,
    jpeg_info.output_components*sizeof(*jpeg_pixels));
  if (memory_info == (MemoryInfo *) NULL)
    {
      jpeg_destroy_decompress(&jpeg_info);
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    }
  jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);
  /*
    Convert JPEG pixels to pixel packets.
  */
  if (setjmp(error_manager.error_recovery) != 0)
    {
      if (memory_info != (MemoryInfo *) NULL)
        memory_info=RelinquishVirtualMemory(memory_info);
      jpeg_destroy_decompress(&jpeg_info);
      (void) CloseBlob(image);
      number_pixels=(MagickSizeType) image->columns*image->rows;
      if (number_pixels != 0)
        return(GetFirstImageInList(image));
      return(DestroyImage(image));
    }
  if (jpeg_info.quantize_colors != 0)
    {
      image->colors=(size_t) jpeg_info.actual_number_of_colors;
      if (jpeg_info.out_color_space == JCS_GRAYSCALE)
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);
          image->colormap[i].green=image->colormap[i].red;
          image->colormap[i].blue=image->colormap[i].red;
          image->colormap[i].opacity=OpaqueOpacity;
        }
      else
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);
          image->colormap[i].green=ScaleCharToQuantum(jpeg_info.colormap[1][i]);
          image->colormap[i].blue=ScaleCharToQuantum(jpeg_info.colormap[2][i]);
          image->colormap[i].opacity=OpaqueOpacity;
        }
    }
  scanline[0]=(JSAMPROW) jpeg_pixels;
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register IndexPacket
      *magick_restrict indexes;

    register ssize_t
      x;

    register PixelPacket
      *magick_restrict q;

    if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)
      {
        (void) ThrowMagickException(exception,GetMagickModule(),
          CorruptImageWarning,""SkipToSyncByte"",""`%s'"",image->filename);
        continue;
      }
    p=jpeg_pixels;
    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (PixelPacket *) NULL)
      break;
    indexes=GetAuthenticIndexQueue(image);
    if (jpeg_info.data_precision > 8)
      {
        unsigned short
          scale;

        scale=65535/(unsigned short) GetQuantumRange((size_t)
          jpeg_info.data_precision);
        if (jpeg_info.output_components == 1)
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            size_t
              pixel;

            pixel=(size_t) (scale*GETJSAMPLE(*p));
            index=ConstrainColormapIndex(image,pixel);
            SetPixelIndex(indexes+x,index);
            SetPixelRGBO(q,image->colormap+(ssize_t) index);
            p++;
            q++;
          }
        else
          if (image->colorspace != CMYKColorspace)
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelRed(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelGreen(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelBlue(q,ScaleShortToQuantum((unsigned short)
                (scale*GETJSAMPLE(*p++))));
              SetPixelOpacity(q,OpaqueOpacity);
              q++;
            }
          else
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelCyan(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelMagenta(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelYellow(q,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelBlack(indexes+x,QuantumRange-ScaleShortToQuantum(
                (unsigned short) (scale*GETJSAMPLE(*p++))));
              SetPixelOpacity(q,OpaqueOpacity);
              q++;
            }
      }
    else
      if (jpeg_info.output_components == 1)
        for (x=0; x < (ssize_t) image->columns; x++)
        {
          index=ConstrainColormapIndex(image,(size_t) GETJSAMPLE(*p));
          SetPixelIndex(indexes+x,index);
          SetPixelRGBO(q,image->colormap+(ssize_t) index);
          p++;
          q++;
        }
      else
        if (image->colorspace != CMYKColorspace)
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelGreen(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelBlue(q,ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelOpacity(q,OpaqueOpacity);
            q++;
          }
        else
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelCyan(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelMagenta(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelYellow(q,QuantumRange-ScaleCharToQuantum((unsigned char)
              GETJSAMPLE(*p++)));
            SetPixelBlack(indexes+x,QuantumRange-ScaleCharToQuantum(
              (unsigned char) GETJSAMPLE(*p++)));
            SetPixelOpacity(q,OpaqueOpacity);
            q++;
          }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
      image->rows);
    if (status == MagickFalse)
      {
        jpeg_abort_decompress(&jpeg_info);
        break;
      }
  }
  if (status != MagickFalse)
    {
      error_manager.finished=MagickTrue;
      if (setjmp(error_manager.error_recovery) == 0)
        (void) jpeg_finish_decompress(&jpeg_info);
    }
  /*
    Free jpeg resources.
  */
  jpeg_destroy_decompress(&jpeg_info);
  memory_info=RelinquishVirtualMemory(memory_info);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
",agree
CVE-2019-10714," MagickExport int LocaleUppercase(const int c)
 {
  if (c < 0)
     return(c);
 #if defined(MAGICKCORE_LOCALE_SUPPORT)
   if (c_locale != (locale_t) NULL)
    return(toupper_l((int) ((unsigned char) c),c_locale));
#endif
  return(toupper((int) ((unsigned char) c)));
}
",agree
CVE-2017-3733,"int tls1_mac(SSL *ssl, SSL3_RECORD *rec, unsigned char *md, int send)
{
    unsigned char *seq;
    EVP_MD_CTX *hash;
    size_t md_size;
    int i;
    EVP_MD_CTX *hmac = NULL, *mac_ctx;
    unsigned char header[13];
    int stream_mac = (send ? (ssl->mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM)
                      : (ssl->mac_flags & SSL_MAC_FLAG_READ_MAC_STREAM));
    int t;

    if (send) {
        seq = RECORD_LAYER_get_write_sequence(&ssl->rlayer);
        hash = ssl->write_hash;
    } else {
        seq = RECORD_LAYER_get_read_sequence(&ssl->rlayer);
        hash = ssl->read_hash;
    }

    t = EVP_MD_CTX_size(hash);
    OPENSSL_assert(t >= 0);
    md_size = t;

    /* I should fix this up TLS TLS TLS TLS TLS XXXXXXXX */
    if (stream_mac) {
        mac_ctx = hash;
    } else {
        hmac = EVP_MD_CTX_new();
        if (hmac == NULL || !EVP_MD_CTX_copy(hmac, hash))
            return -1;
        mac_ctx = hmac;
    }

    if (SSL_IS_DTLS(ssl)) {
        unsigned char dtlsseq[8], *p = dtlsseq;

        s2n(send ? DTLS_RECORD_LAYER_get_w_epoch(&ssl->rlayer) :
            DTLS_RECORD_LAYER_get_r_epoch(&ssl->rlayer), p);
        memcpy(p, &seq[2], 6);

        memcpy(header, dtlsseq, 8);
    } else
        memcpy(header, seq, 8);

    header[8] = rec->type;
    header[9] = (unsigned char)(ssl->version >> 8);
    header[10] = (unsigned char)(ssl->version);
     header[11] = (rec->length) >> 8;
     header[12] = (rec->length) & 0xff;
 
    if (!send && !SSL_USE_ETM(ssl) &&
         EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
         ssl3_cbc_record_digest_supported(mac_ctx)) {
         /*
         * This is a CBC-encrypted record. We must avoid leaking any
         * timing-side channel information about how many blocks of data we
         * are hashing because that gives an attacker a timing-oracle.
         */
        /* Final param == not SSLv3 */
        if (ssl3_cbc_digest_record(mac_ctx,
                                   md, &md_size,
                                   header, rec->input,
                                   rec->length + md_size, rec->orig_len,
                                   ssl->s3->read_mac_secret,
                                   ssl->s3->read_mac_secret_size, 0) <= 0) {
            EVP_MD_CTX_free(hmac);
            return -1;
        }
    } else {
        if (EVP_DigestSignUpdate(mac_ctx, header, sizeof(header)) <= 0
            || EVP_DigestSignUpdate(mac_ctx, rec->input, rec->length) <= 0
            || EVP_DigestSignFinal(mac_ctx, md, &md_size) <= 0) {
             EVP_MD_CTX_free(hmac);
             return -1;
         }
        if (!send && !SSL_USE_ETM(ssl) && FIPS_mode())
             if (!tls_fips_digest_extra(ssl->enc_read_ctx,
                                        mac_ctx, rec->input,
                                        rec->length, rec->orig_len)) {
                EVP_MD_CTX_free(hmac);
                return -1;
            }
    }

    EVP_MD_CTX_free(hmac);

#ifdef SSL_DEBUG
    fprintf(stderr, ""seq="");
    {
        int z;
        for (z = 0; z < 8; z++)
            fprintf(stderr, ""%02X "", seq[z]);
        fprintf(stderr, ""\n"");
    }
    fprintf(stderr, ""rec="");
    {
        unsigned int z;
        for (z = 0; z < rec->length; z++)
            fprintf(stderr, ""%02X "", rec->data[z]);
        fprintf(stderr, ""\n"");
    }
#endif

    if (!SSL_IS_DTLS(ssl)) {
        for (i = 7; i >= 0; i--) {
            ++seq[i];
            if (seq[i] != 0)
                break;
        }
    }
#ifdef SSL_DEBUG
    {
        unsigned int z;
        for (z = 0; z < md_size; z++)
            fprintf(stderr, ""%02X "", md[z]);
        fprintf(stderr, ""\n"");
    }
#endif
    return (md_size);
}
",agree
CVE-2019-5799,"void DocumentLoader::InstallNewDocument(
    const KURL& url,
    Document* owner_document,
    WebGlobalObjectReusePolicy global_object_reuse_policy,
    const AtomicString& mime_type,
    const AtomicString& encoding,
    InstallNewDocumentReason reason,
    ParserSynchronizationPolicy parsing_policy,
    const KURL& overriding_url) {
  DCHECK(!frame_->GetDocument() || !frame_->GetDocument()->IsActive());
  DCHECK_EQ(frame_->Tree().ChildCount(), 0u);
  if (GetFrameLoader().StateMachine()->IsDisplayingInitialEmptyDocument()) {
    GetFrameLoader().StateMachine()->AdvanceTo(
        FrameLoaderStateMachine::kCommittedFirstRealLoad);
   }
 
   const SecurityOrigin* previous_security_origin = nullptr;
  const ContentSecurityPolicy* previous_csp = nullptr;
   if (frame_->GetDocument()) {
     previous_security_origin = frame_->GetDocument()->GetSecurityOrigin();
    previous_csp = frame_->GetDocument()->GetContentSecurityPolicy();
   }
 
  if (global_object_reuse_policy != WebGlobalObjectReusePolicy::kUseExisting)
    frame_->SetDOMWindow(LocalDOMWindow::Create(*frame_));

  if (reason == InstallNewDocumentReason::kNavigation)
    WillCommitNavigation();

  Document* document = frame_->DomWindow()->InstallNewDocument(
      mime_type,
      DocumentInit::Create()
           .WithDocumentLoader(this)
           .WithURL(url)
           .WithOwnerDocument(owner_document)
          .WithNewRegistrationContext()
          .WithPreviousDocumentCSP(previous_csp),
       false);
 
  if (frame_->IsMainFrame())
    frame_->ClearActivation();

  if (frame_->HasReceivedUserGestureBeforeNavigation() !=
      had_sticky_activation_) {
    frame_->SetDocumentHasReceivedUserGestureBeforeNavigation(
        had_sticky_activation_);
    GetLocalFrameClient().SetHasReceivedUserGestureBeforeNavigation(
        had_sticky_activation_);
  }

  if (ShouldClearWindowName(*frame_, previous_security_origin, *document)) {
    frame_->Tree().ExperimentalSetNulledName();
  }
 
   if (!overriding_url.IsEmpty())
     document->SetBaseURLOverride(overriding_url);
  DidInstallNewDocument(document, previous_csp);
 
  if (reason == InstallNewDocumentReason::kNavigation)
    DidCommitNavigation(global_object_reuse_policy);

  if (GetFrameLoader().StateMachine()->CommittedFirstRealDocumentLoad()) {
    if (document->GetSettings()
            ->GetForceTouchEventFeatureDetectionForInspector()) {
      OriginTrialContext::FromOrCreate(document)->AddFeature(
          ""ForceTouchEventFeatureDetectionForInspector"");
    }
    OriginTrialContext::AddTokensFromHeader(
        document, response_.HttpHeaderField(http_names::kOriginTrial));
  }
  bool stale_while_revalidate_enabled =
      origin_trials::StaleWhileRevalidateEnabled(document);
  fetcher_->SetStaleWhileRevalidateEnabled(stale_while_revalidate_enabled);

  if (stale_while_revalidate_enabled &&
      !RuntimeEnabledFeatures::StaleWhileRevalidateEnabledByRuntimeFlag())
    UseCounter::Count(frame_, WebFeature::kStaleWhileRevalidateEnabled);

  parser_ = document->OpenForNavigation(parsing_policy, mime_type, encoding);

  ScriptableDocumentParser* scriptable_parser =
      parser_->AsScriptableDocumentParser();
  if (scriptable_parser && GetResource()) {
    scriptable_parser->SetInlineScriptCacheHandler(
        ToRawResource(GetResource())->InlineScriptCacheHandler());
  }

  WTF::String feature_policy(
      response_.HttpHeaderField(http_names::kFeaturePolicy));
  MergeFeaturesFromOriginPolicy(feature_policy, request_.GetOriginPolicy());
  document->ApplyFeaturePolicyFromHeader(feature_policy);

  GetFrameLoader().DispatchDidClearDocumentOfWindowObject();
}
",agree
CVE-2018-16068,"DataPipeConsumerDispatcher::Deserialize(const void* data,
                                        size_t num_bytes,
                                        const ports::PortName* ports,
                                        size_t num_ports,
                                        PlatformHandle* handles,
                                        size_t num_handles) {
  if (num_ports != 1 || num_handles != 1 ||
      num_bytes != sizeof(SerializedState)) {
    return nullptr;
  }
 
   const SerializedState* state = static_cast<const SerializedState*>(data);
   if (!state->options.capacity_num_bytes || !state->options.element_num_bytes ||
      state->options.capacity_num_bytes < state->options.element_num_bytes) {
     return nullptr;
   }
 
  NodeController* node_controller = Core::Get()->GetNodeController();
  ports::PortRef port;
  if (node_controller->node()->GetPort(ports[0], &port) != ports::OK)
    return nullptr;

  auto region_handle = CreateSharedMemoryRegionHandleFromPlatformHandles(
      std::move(handles[0]), PlatformHandle());
  auto region = base::subtle::PlatformSharedMemoryRegion::Take(
      std::move(region_handle),
      base::subtle::PlatformSharedMemoryRegion::Mode::kUnsafe,
      state->options.capacity_num_bytes,
      base::UnguessableToken::Deserialize(state->buffer_guid_high,
                                          state->buffer_guid_low));
  auto ring_buffer =
      base::UnsafeSharedMemoryRegion::Deserialize(std::move(region));
  if (!ring_buffer.IsValid()) {
    DLOG(ERROR) << ""Failed to deserialize shared buffer handle."";
    return nullptr;
  }

  scoped_refptr<DataPipeConsumerDispatcher> dispatcher =
      new DataPipeConsumerDispatcher(node_controller, port,
                                     std::move(ring_buffer), state->options,
                                     state->pipe_id);

  {
    base::AutoLock lock(dispatcher->lock_);
    dispatcher->read_offset_ = state->read_offset;
    dispatcher->bytes_available_ = state->bytes_available;
    dispatcher->new_data_available_ = state->bytes_available > 0;
     dispatcher->peer_closed_ = state->flags & kFlagPeerClosed;
     if (!dispatcher->InitializeNoLock())
       return nullptr;
     dispatcher->UpdateSignalsStateNoLock();
   }
 
  return dispatcher;
}
",neutral
CVE-2011-1296," void FindBarController::UpdateFindBarForCurrentResult() {
  FindManager* find_manager = tab_contents_->GetFindManager();
  const FindNotificationDetails& find_result = find_manager->find_result();
 
  if (find_result.number_of_matches() > -1) {
    if (last_reported_matchcount_ > 0 &&
        find_result.number_of_matches() == 1 &&
        !find_result.final_update())
      return;  // Don't let interim result override match count.
     last_reported_matchcount_ = find_result.number_of_matches();
   }
 
  find_bar_->UpdateUIForFindResult(find_result, find_manager->find_text());
 }
",agree
CVE-2017-18079,"static void i8042_stop(struct serio *serio)
 {
 	struct i8042_port *port = serio->port_data;
 
 	port->exists = false;
 
 	/*
 	 * We synchronize with both AUX and KBD IRQs because there is
 	 * a (very unlikely) chance that AUX IRQ is raised for KBD port
 	 * and vice versa.
 	 */
 	synchronize_irq(I8042_AUX_IRQ);
 	synchronize_irq(I8042_KBD_IRQ);
	port->serio = NULL;
 }
",agree
CVE-2016-3742,"WORD32 ih264d_process_intra_mb(dec_struct_t * ps_dec,
 dec_mb_info_t * ps_cur_mb_info,
                               UWORD8 u1_mb_num)
{
    UWORD8 u1_mb_type = ps_cur_mb_info->u1_mb_type;
    UWORD8 uc_temp = ps_cur_mb_info->u1_mb_ngbr_availablity;
    UWORD8 u1_top_available = BOOLEAN(uc_temp & TOP_MB_AVAILABLE_MASK);
    UWORD8 u1_left_available = BOOLEAN(uc_temp & LEFT_MB_AVAILABLE_MASK);
    UWORD8 u1_use_top_right_mb = BOOLEAN(uc_temp & TOP_RIGHT_MB_AVAILABLE_MASK);
    UWORD8 u1_use_top_left_mb = BOOLEAN(uc_temp & TOP_LEFT_MB_AVAILABLE_MASK);
    UWORD8 uc_useTopMB = u1_top_available;
    UWORD16 u2_use_left_mb = u1_left_available;
    UWORD16 u2_use_left_mb_pack;
    UWORD8 *pu1_luma_pred_buffer;
 /* CHANGED CODE */
    UWORD8 *pu1_luma_rec_buffer;
    UWORD8 *puc_top;

 mb_neigbour_params_t *ps_left_mb;
 mb_neigbour_params_t *ps_top_mb;
 mb_neigbour_params_t *ps_top_right_mb;
 mb_neigbour_params_t *ps_curmb;

    UWORD16 u2_mbx = ps_cur_mb_info->u2_mbx;
    UWORD32 ui_pred_width, ui_rec_width;
    WORD16 *pi2_y_coeff;
    UWORD8 u1_mbaff, u1_topmb, u1_mb_field_decoding_flag;
    UWORD32 u4_num_pmbair;
    UWORD16 ui2_luma_csbp = ps_cur_mb_info->u2_luma_csbp;
    UWORD8 *pu1_yleft, *pu1_ytop_left;
 /* Chroma variables*/
    UWORD8 *pu1_top_u;
    UWORD8 *pu1_uleft;
    UWORD8 *pu1_u_top_left;
 /* CHANGED CODE */
    UWORD8 *pu1_mb_cb_rei1_buffer, *pu1_mb_cr_rei1_buffer;
    UWORD32 u4_recwidth_cr;
 /* CHANGED CODE */
 tfr_ctxt_t *ps_frame_buf = ps_dec->ps_frame_buf_ip_recon;
    UWORD32 u4_luma_dc_only_csbp = 0;
    UWORD32 u4_luma_dc_only_cbp = 0;

    UWORD8 *pu1_prev_intra4x4_pred_mode_data = (UWORD8 *)ps_dec->pv_proc_tu_coeff_data; //Pointer to keep track of intra4x4_pred_mode data in pv_proc_tu_coeff_data buffer
    u1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag;
    u1_topmb = ps_cur_mb_info->u1_topmb;
    u4_num_pmbair = (u1_mb_num >> u1_mbaff);


 /*--------------------------------------------------------------------*/
 /* Find the current MB's mb params                                    */
 /*--------------------------------------------------------------------*/
    u1_mb_field_decoding_flag = ps_cur_mb_info->u1_mb_field_decodingflag;

    ps_curmb = ps_cur_mb_info->ps_curmb;
    ps_top_mb = ps_cur_mb_info->ps_top_mb;
    ps_left_mb = ps_cur_mb_info->ps_left_mb;
    ps_top_right_mb = ps_cur_mb_info->ps_top_right_mb;

 /*--------------------------------------------------------------------*/
 /* Check whether neighbouring MB is Inter MB and                      */
 /* constrained intra pred is 1.                                       */
 /*--------------------------------------------------------------------*/
    u2_use_left_mb_pack = (u2_use_left_mb << 8) + u2_use_left_mb;

 if(ps_dec->ps_cur_pps->u1_constrained_intra_pred_flag)
 {
        UWORD8 u1_left = (UWORD8)u2_use_left_mb;

        uc_useTopMB = uc_useTopMB
 && ((ps_top_mb->u1_mb_type != P_MB)
 && (ps_top_mb->u1_mb_type != B_MB));
        u2_use_left_mb = u2_use_left_mb
 && ((ps_left_mb->u1_mb_type != P_MB)
 && (ps_left_mb->u1_mb_type != B_MB));

        u2_use_left_mb_pack = (u2_use_left_mb << 8) + u2_use_left_mb;
 if(u1_mbaff)
 {
 if(u1_mb_field_decoding_flag ^ ps_left_mb->u1_mb_fld)
 {
                u1_left = u1_left
 && (((ps_left_mb + 1)->u1_mb_type != P_MB)
 && ((ps_left_mb + 1)->u1_mb_type
 != B_MB));
                u2_use_left_mb = u2_use_left_mb && u1_left;
 if(u1_mb_field_decoding_flag)
                    u2_use_left_mb_pack = (u1_left << 8)
 + (u2_use_left_mb_pack & 0xff);
 else
                    u2_use_left_mb_pack = (u2_use_left_mb << 8)
 + (u2_use_left_mb);
 }
 }
        u1_use_top_right_mb =
                        u1_use_top_right_mb
 && ((ps_top_right_mb->u1_mb_type != P_MB)
 && (ps_top_right_mb->u1_mb_type
 != B_MB));

        u1_use_top_left_mb =
                        u1_use_top_left_mb
 && ((ps_cur_mb_info->u1_topleft_mbtype != P_MB)
 && (ps_cur_mb_info->u1_topleft_mbtype
 != B_MB));
 }

 /*********************Common pointer calculations *************************/
 /* CHANGED CODE */
    pu1_luma_pred_buffer = ps_dec->pu1_y;
    pu1_luma_rec_buffer = ps_frame_buf->pu1_dest_y + (u4_num_pmbair << 4);
    pu1_mb_cb_rei1_buffer = ps_frame_buf->pu1_dest_u
 + (u4_num_pmbair << 3) * YUV420SP_FACTOR;
    pu1_mb_cr_rei1_buffer = ps_frame_buf->pu1_dest_v + (u4_num_pmbair << 3);
    ui_pred_width = MB_SIZE;
    ui_rec_width = ps_dec->u2_frm_wd_y << u1_mb_field_decoding_flag;
    u4_recwidth_cr = ps_dec->u2_frm_wd_uv << u1_mb_field_decoding_flag;
 /************* Current and top luma pointer *****************/

 if(u1_mbaff)
 {
 if(u1_topmb == 0)
 {
            pu1_luma_rec_buffer += (
                            u1_mb_field_decoding_flag ?
 (ui_rec_width >> 1) :
 (ui_rec_width << 4));
            pu1_mb_cb_rei1_buffer += (
                            u1_mb_field_decoding_flag ?
 (u4_recwidth_cr >> 1) :
 (u4_recwidth_cr << 3));
            pu1_mb_cr_rei1_buffer += (
                            u1_mb_field_decoding_flag ?
 (u4_recwidth_cr >> 1) :
 (u4_recwidth_cr << 3));
 }
 }

 /* CHANGED CODE */
 if(ps_dec->u4_use_intrapred_line_copy == 1)
 {
        puc_top = ps_dec->pu1_prev_y_intra_pred_line + (ps_cur_mb_info->u2_mbx << 4);
        pu1_top_u = ps_dec->pu1_prev_u_intra_pred_line
 + (ps_cur_mb_info->u2_mbx << 3) * YUV420SP_FACTOR;
 }
 else
 {
        puc_top = pu1_luma_rec_buffer - ui_rec_width;
        pu1_top_u = pu1_mb_cb_rei1_buffer - u4_recwidth_cr;
 }
 /* CHANGED CODE */

 /************* Left pointer *****************/
    pu1_yleft = pu1_luma_rec_buffer - 1;
    pu1_uleft = pu1_mb_cb_rei1_buffer - 1 * YUV420SP_FACTOR;

 /**************Top Left pointer calculation**********/
    pu1_ytop_left = puc_top - 1;
    pu1_u_top_left = pu1_top_u - 1 * YUV420SP_FACTOR;

 /* CHANGED CODE */
    PROFILE_DISABLE_INTRA_PRED()
 {
        pu1_prev_intra4x4_pred_mode_data = (UWORD8 *)ps_dec->pv_proc_tu_coeff_data;
 if(u1_mb_type == I_4x4_MB && ps_cur_mb_info->u1_tran_form8x8 == 0)
 {
            ps_dec->pv_proc_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_proc_tu_coeff_data + 32);

 }
 else if (u1_mb_type == I_4x4_MB && ps_cur_mb_info->u1_tran_form8x8 == 1)
 {
            ps_dec->pv_proc_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_proc_tu_coeff_data + 8);
 }
 }
 if(!ps_cur_mb_info->u1_tran_form8x8)
 {
        u4_luma_dc_only_csbp = ih264d_unpack_luma_coeff4x4_mb(ps_dec,
                                       ps_cur_mb_info,
 1);
 }
 else
 {
 if(!ps_dec->ps_cur_pps->u1_entropy_coding_mode)
 {
            u4_luma_dc_only_cbp = ih264d_unpack_luma_coeff4x4_mb(ps_dec,
                                           ps_cur_mb_info,
 1);
 }
 else
 {
            u4_luma_dc_only_cbp = ih264d_unpack_luma_coeff8x8_mb(ps_dec,
                                           ps_cur_mb_info);
 }
 }

    pi2_y_coeff = ps_dec->pi2_coeff_data;

 if(u1_mb_type != I_4x4_MB)
 {
        UWORD8 u1_intrapred_mode = MB_TYPE_TO_INTRA_16x16_MODE(u1_mb_type);
 /*--------------------------------------------------------------------*/
 /* 16x16 IntraPrediction                                              */
 /*--------------------------------------------------------------------*/
 {
            UWORD8 u1_packed_modes = (u1_top_available << 1)
 + u1_left_available;
            UWORD8 u1_err_code =
 (u1_intrapred_mode & 1) ?
                                            u1_intrapred_mode :
 (u1_intrapred_mode ^ 2);

 if((u1_err_code & u1_packed_modes) ^ u1_err_code)
 {
                u1_intrapred_mode = 0;
                ps_dec->i4_error_code = ERROR_INTRAPRED;
 }
 }
 {
            UWORD8 au1_ngbr_pels[33];
 /* Get neighbour pixels */
 /* left pels */
 if(u2_use_left_mb)
 {
                WORD32 i;
 for(i = 0; i < 16; i++)
                    au1_ngbr_pels[16 - 1 - i] = pu1_yleft[i * ui_rec_width];
 }
 else
 {
                memset(au1_ngbr_pels, 0, 16);
 }

 /* top left pels */
            au1_ngbr_pels[16] = *pu1_ytop_left;

 /* top pels */
 if(uc_useTopMB)
 {
                memcpy(au1_ngbr_pels + 16 + 1, puc_top, 16);
 }
 else
 {
                memset(au1_ngbr_pels + 16 + 1, 0, 16);
 }
            PROFILE_DISABLE_INTRA_PRED()
            ps_dec->apf_intra_pred_luma_16x16[u1_intrapred_mode](
                            au1_ngbr_pels, pu1_luma_rec_buffer, 1, ui_rec_width,
 ((uc_useTopMB << 2) | u2_use_left_mb));
 }
 {
            UWORD32 i;
            WORD16 ai2_tmp[16];
 for(i = 0; i < 16; i++)
 {
                WORD16 *pi2_level = pi2_y_coeff + (i << 4);
                UWORD8 *pu1_pred_sblk = pu1_luma_rec_buffer
 + ((i & 0x3) * BLK_SIZE)
 + (i >> 2) * (ui_rec_width << 2);
                PROFILE_DISABLE_IQ_IT_RECON()
 {
 if(CHECKBIT(ps_cur_mb_info->u2_luma_csbp, i))
 {
                        ps_dec->pf_iquant_itrans_recon_luma_4x4(
                                        pi2_level,
                                        pu1_pred_sblk,
                                        pu1_pred_sblk,
                                        ui_rec_width,
                                        ui_rec_width,
                                        gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],
 (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],
                                        ps_cur_mb_info->u1_qp_div6, ai2_tmp, 1,
                                        pi2_level);
 }
 else if((CHECKBIT(u4_luma_dc_only_csbp, i)) && pi2_level[0] != 0)
 {
                        ps_dec->pf_iquant_itrans_recon_luma_4x4_dc(
                                        pi2_level,
                                        pu1_pred_sblk,
                                        pu1_pred_sblk,
                                        ui_rec_width,
                                        ui_rec_width,
                                        gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],
 (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],
                                        ps_cur_mb_info->u1_qp_div6, ai2_tmp, 1,
                                        pi2_level);
 }
 }
 }
 }
 }
 else if(!ps_cur_mb_info->u1_tran_form8x8)
 {
        UWORD8 u1_is_left_sub_block, u1_is_top_sub_block = uc_useTopMB;
        UWORD8 u1_sub_blk_x, u1_sub_blk_y, u1_sub_mb_num;
        WORD8 i1_top_pred_mode;
        WORD8 i1_left_pred_mode;
        UWORD8 *pu1_top, *pu1_left, *pu1_top_left, *pu1_top_right;
        WORD8 *pi1_cur_pred_mode, *pi1_left_pred_mode, *pc_topPredMode;
        UWORD16 ui2_left_pred_buf_width = 0xffff;
        WORD8 i1_intra_pred;
        UWORD8 *pu1_prev_intra4x4_pred_mode_flag = pu1_prev_intra4x4_pred_mode_data;
        UWORD8 *pu1_rem_intra4x4_pred_mode = pu1_prev_intra4x4_pred_mode_data + 16;
        WORD16 *pi2_y_coeff1;
        UWORD8 u1_cur_sub_block;
        UWORD16 ui2_top_rt_mask;

 /*--------------------------------------------------------------------*/
 /* 4x4 IntraPrediction                                                */
 /*--------------------------------------------------------------------*/
 /* Calculation of Top Right subblock mask                             */
 /*                                                                    */
 /* (a) Set it to default mask                                         */
 /*     [It has 0 for sublocks which will never have top-right sub block] */
 /*                                                                    */
 /* (b) If top MB is not available                                     */
 /*      Clear the bits of the first row sub blocks                    */
 /*                                                                    */
 /* (c) Set/Clear bit for top-right sublock of MB                      */
 /*      [5 sub-block in decoding order] based on TOP RIGHT MB availablity */
 /*--------------------------------------------------------------------*/

        pu1_top = puc_top;

        ui2_top_rt_mask = (u1_use_top_right_mb << 3) | (0x5750);
 if(uc_useTopMB)
            ui2_top_rt_mask |= 0x7;

 /*Top Related initialisations*/


        pi1_cur_pred_mode = ps_cur_mb_info->ps_curmb->pi1_intrapredmodes;
        pc_topPredMode = ps_cur_mb_info->ps_top_mb->pi1_intrapredmodes;
 /*--------------------------------------
         if(u1_mbaff)
         {

         pi1_cur_pred_mode += (u2_mbx << 2);
         pc_topPredMode = pi1_cur_pred_mode + ps_cur_mb_info->i1_offset;
         pi1_cur_pred_mode += (u1_topmb) ? 0: 4;
         }*/

 if(u1_top_available)
 {
 if(ps_top_mb->u1_mb_type == I_4x4_MB)
 *(WORD32*)pi1_cur_pred_mode = *(WORD32*)pc_topPredMode;
 else
 *(WORD32*)pi1_cur_pred_mode =
 (uc_useTopMB) ? DC_DC_DC_DC : NOT_VALID;
 }
 else
 *(WORD32*)pi1_cur_pred_mode = NOT_VALID;
 /* CHANGED CODE */

 /* CHANGED CODE */

 /*Left Related initialisations*/
        pi1_left_pred_mode = ps_dec->pi1_left_pred_mode;
 if(!u1_mbaff)
 {

 if(u1_left_available)
 {

 if(ps_left_mb->u1_mb_type != I_4x4_MB)
 *(WORD32*)pi1_left_pred_mode =
 (u2_use_left_mb_pack) ?
                                    DC_DC_DC_DC :
                                                            NOT_VALID;

 }
 else
 {

 *(WORD32*)pi1_left_pred_mode = NOT_VALID;
 }

 }
 else
 {
            UWORD8 u1_curMbfld = ps_cur_mb_info->u1_mb_field_decodingflag;
            UWORD8 u1_leftMbfld = ps_left_mb->u1_mb_fld;

 if(u1_curMbfld ^ u1_leftMbfld)
 {

 if(u1_topmb
 | ((u1_topmb == 0)
 && ((ps_curmb - 1)->u1_mb_type
 != I_4x4_MB)))
 {
 if(u1_left_available)
 {
 if(ps_left_mb->u1_mb_type != I_4x4_MB)
 {
 if(CHECKBIT(u2_use_left_mb_pack,0) == 0)
 *(WORD32*)pi1_left_pred_mode = NOT_VALID;
 else
 *(WORD32*)pi1_left_pred_mode = DC_DC_DC_DC;
 }
 }
 else
 *(WORD32*)pi1_left_pred_mode = NOT_VALID;

 if(u1_curMbfld)
 {
 if(u1_left_available)
 {
 if((ps_left_mb + 1)->u1_mb_type != I_4x4_MB)
 {
 if(u2_use_left_mb_pack >> 8)
 *(WORD32*)(pi1_left_pred_mode + 4) =
                                                    DC_DC_DC_DC;
 else
 *(WORD32*)(pi1_left_pred_mode + 4) =
                                                    NOT_VALID;
 }
 }
 else
 *(WORD32*)(pi1_left_pred_mode + 4) = NOT_VALID;
                        pi1_left_pred_mode[1] = pi1_left_pred_mode[2];
                        pi1_left_pred_mode[2] = pi1_left_pred_mode[4];
                        pi1_left_pred_mode[3] = pi1_left_pred_mode[6];
 *(WORD32*)(pi1_left_pred_mode + 4) =
 *(WORD32*)pi1_left_pred_mode;
 }
 else
 {

                        pi1_left_pred_mode[7] = pi1_left_pred_mode[3];
                        pi1_left_pred_mode[6] = pi1_left_pred_mode[3];
                        pi1_left_pred_mode[5] = pi1_left_pred_mode[2];
                        pi1_left_pred_mode[4] = pi1_left_pred_mode[2];
                        pi1_left_pred_mode[3] = pi1_left_pred_mode[1];
                        pi1_left_pred_mode[2] = pi1_left_pred_mode[1];
                        pi1_left_pred_mode[1] = pi1_left_pred_mode[0];
 }
 }
                pi1_left_pred_mode += (u1_topmb) ? 0 : 4;
 }
 else
 {

                pi1_left_pred_mode += (u1_topmb) ? 0 : 4;
 if(u1_left_available)
 {

 if(ps_left_mb->u1_mb_type != I_4x4_MB)
 *(WORD32*)pi1_left_pred_mode =
 (u2_use_left_mb_pack) ?
                                        DC_DC_DC_DC :
                                                                NOT_VALID;
 }
 else
 *(WORD32*)pi1_left_pred_mode = NOT_VALID;
 }
 }
 /* One time pointer initialisations*/
        pi2_y_coeff1 = pi2_y_coeff;
        pu1_top_left = pu1_ytop_left;

 /* Scan the sub-blocks in Raster Scan Order */
 for(u1_sub_mb_num = 0; u1_sub_mb_num < 16; u1_sub_mb_num++)
 {
            UWORD8 au1_ngbr_pels[13];

            u1_sub_blk_x = u1_sub_mb_num & 0x3;
            u1_sub_blk_y = u1_sub_mb_num >> 2;
            i1_top_pred_mode = pi1_cur_pred_mode[u1_sub_blk_x];
            i1_left_pred_mode = pi1_left_pred_mode[u1_sub_blk_y];
            u1_use_top_right_mb = (!!CHECKBIT(ui2_top_rt_mask, u1_sub_mb_num));

 /*********** left subblock availability**********/
 if(u1_sub_blk_x)
                u1_is_left_sub_block = 1;
 else
                u1_is_left_sub_block =
 (u1_sub_blk_y < 2) ?
 (CHECKBIT(u2_use_left_mb_pack,
 0)) :
 (u2_use_left_mb_pack >> 8);

 /* CHANGED CODE */
 if(u1_sub_blk_y)
                u1_is_top_sub_block = 1;

 /* CHANGED CODE */
 /***************** Top *********************/
 if(ps_dec->u4_use_intrapred_line_copy == 1)
 {

 if(u1_sub_blk_y)
                    pu1_top = pu1_luma_rec_buffer - ui_rec_width;
 else
                    pu1_top = puc_top + (u1_sub_blk_x << 2);
 }
 else
 {
                pu1_top = pu1_luma_rec_buffer - ui_rec_width;
 }
 /***************** Top Right *********************/
            pu1_top_right = pu1_top + 4;
 /***************** Top Left *********************/
            pu1_top_left = pu1_top - 1;
 /***************** Left *********************/
            pu1_left = pu1_luma_rec_buffer - 1;
 /* CHANGED CODE */

 /*---------------------------------------------------------------*/
 /* Calculation of Intra prediction mode                          */
 /*---------------------------------------------------------------*/
            i1_intra_pred = ((i1_left_pred_mode < 0) | (i1_top_pred_mode < 0)) ?
                            DC : MIN(i1_left_pred_mode, i1_top_pred_mode);
 {
                UWORD8 u1_packed_modes = (u1_is_top_sub_block << 1)
 + u1_is_left_sub_block;
                UWORD8 *pu1_intra_err_codes =
 (UWORD8 *)gau1_ih264d_intra_pred_err_code;
                UWORD8 uc_b2b0 = ((u1_sub_mb_num & 4) >> 1) | (u1_sub_mb_num & 1);
                UWORD8 uc_b3b1 = ((u1_sub_mb_num & 8) >> 2)
 | ((u1_sub_mb_num & 2) >> 1);

                u1_cur_sub_block = (uc_b3b1 << 2) + uc_b2b0;
                PROFILE_DISABLE_INTRA_PRED()
 if(!pu1_prev_intra4x4_pred_mode_flag[u1_cur_sub_block])
 {
                    i1_intra_pred =
                                    pu1_rem_intra4x4_pred_mode[u1_cur_sub_block]

                                                     + (pu1_rem_intra4x4_pred_mode[u1_cur_sub_block]
                                                                     >= i1_intra_pred);
                 }
                 {
                     UWORD8 u1_err_code = pu1_intra_err_codes[i1_intra_pred];
 
 if((u1_err_code & u1_packed_modes) ^ u1_err_code)
 {
                        i1_intra_pred = 0;
                        ps_dec->i4_error_code = ERROR_INTRAPRED;
 }

 }
 }
 {
 /* Get neighbour pixels */
 /* left pels */
 if(u1_is_left_sub_block)
 {
                    WORD32 i;
 for(i = 0; i < 4; i++)
                        au1_ngbr_pels[4 - 1 - i] = pu1_left[i * ui_rec_width];
 }
 else
 {
                    memset(au1_ngbr_pels, 0, 4);
 }

 /* top left pels */
                au1_ngbr_pels[4] = *pu1_top_left;

 /* top pels */
 if(u1_is_top_sub_block)
 {
                    memcpy(au1_ngbr_pels + 4 + 1, pu1_top, 4);
 }
 else
 {
                    memset(au1_ngbr_pels + 4 + 1, 0, 4);
 }

 /* top right pels */
 if(u1_use_top_right_mb)
 {
                    memcpy(au1_ngbr_pels + 4 * 2 + 1, pu1_top_right, 4);
 }
 else if(u1_is_top_sub_block)
 {
                    memset(au1_ngbr_pels + 4 * 2 + 1, au1_ngbr_pels[4 * 2], 4);
 }
 }
            PROFILE_DISABLE_INTRA_PRED()
            ps_dec->apf_intra_pred_luma_4x4[i1_intra_pred](
                            au1_ngbr_pels, pu1_luma_rec_buffer, 1,
                            ui_rec_width,
 ((u1_is_top_sub_block << 2) | u1_is_left_sub_block));

 /* CHANGED CODE */
 if(CHECKBIT(ui2_luma_csbp, u1_sub_mb_num))
 {
                WORD16 ai2_tmp[16];
                PROFILE_DISABLE_IQ_IT_RECON()
 {
 if(CHECKBIT(u4_luma_dc_only_csbp, u1_sub_mb_num))
 {
                        ps_dec->pf_iquant_itrans_recon_luma_4x4_dc(
                                        pi2_y_coeff1,
                                        pu1_luma_rec_buffer,
                                        pu1_luma_rec_buffer,
                                        ui_rec_width,
                                        ui_rec_width,
                                        gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],
 (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],
                                        ps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,
                                        NULL);
 }
 else
 {
                        ps_dec->pf_iquant_itrans_recon_luma_4x4(
                                        pi2_y_coeff1,
                                        pu1_luma_rec_buffer,
                                        pu1_luma_rec_buffer,
                                        ui_rec_width,
                                        ui_rec_width,
                                        gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qp_rem6],
 (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[0],
                                        ps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,
                                        NULL);
 }
 }

 }

 /*---------------------------------------------------------------*/
 /* Update sub block number                                       */
 /*---------------------------------------------------------------*/
            pi2_y_coeff1 += 16;
            pu1_luma_rec_buffer +=
 (u1_sub_blk_x == 3) ? (ui_rec_width << 2) - 12 : 4;
            pu1_luma_pred_buffer +=
 (u1_sub_blk_x == 3) ? (ui_pred_width << 2) - 12 : 4;
 /* CHANGED CODE */
            pi1_cur_pred_mode[u1_sub_blk_x] = i1_intra_pred;
            pi1_left_pred_mode[u1_sub_blk_y] = i1_intra_pred;
 }
 }
 else if((u1_mb_type == I_4x4_MB) && (ps_cur_mb_info->u1_tran_form8x8 == 1))
 {
        UWORD8 u1_is_left_sub_block, u1_is_top_sub_block = uc_useTopMB;
        UWORD8 u1_sub_blk_x, u1_sub_blk_y, u1_sub_mb_num;
        WORD8 i1_top_pred_mode;
        WORD8 i1_left_pred_mode;
        UWORD8 *pu1_top, *pu1_left, *pu1_top_left;
        WORD8 *pi1_cur_pred_mode, *pi1_left_pred_mode, *pc_topPredMode;
        UWORD16 ui2_left_pred_buf_width = 0xffff;
        WORD8 i1_intra_pred;
        UWORD8 *pu1_prev_intra4x4_pred_mode_flag = pu1_prev_intra4x4_pred_mode_data;
        UWORD8 *pu1_rem_intra4x4_pred_mode = pu1_prev_intra4x4_pred_mode_data + 4;
        WORD16 *pi2_y_coeff1;
        UWORD16 ui2_top_rt_mask;
        UWORD32 u4_4x4_left_offset = 0;

 /*--------------------------------------------------------------------*/
 /* 8x8 IntraPrediction                                                */
 /*--------------------------------------------------------------------*/
 /* Calculation of Top Right subblock mask                             */
 /*                                                                    */
 /* (a) Set it to default mask                                         */
 /*  [It has 0 for sublocks which will never have top-right sub block] */
 /*                                                                    */
 /* (b) If top MB is not available                                     */
 /*      Clear the bits of the first row sub blocks                    */
 /*                                                                    */
 /* (c) Set/Clear bit for top-right sublock of MB                      */
 /*  [5 sub-block in decoding order] based on TOP RIGHT MB availablity */
 /*                                                                    */
 /* ui2_top_rt_mask: marks availibility of top right(neighbour)         */
 /* in the 8x8 Block ordering                                          */
 /*                                                                    */
 /*      tr0   tr1                                                     */
 /*   0    1   tr3                                                     */
 /*   2    3                                                           */
 /*                                                                    */
 /*  Top rights for 0 is in top MB                                     */
 /*  top right of 1 will be in top right MB                            */
 /*  top right of 3 in right MB and hence not available                */
 /*  This corresponds to ui2_top_rt_mask  having default value 0x4      */
 /*--------------------------------------------------------------------*/

        ui2_top_rt_mask = (u1_use_top_right_mb << 1) | (0x4);

 if(uc_useTopMB)
 {
            ui2_top_rt_mask |= 0x1;
 }

 /* Top Related initialisations */
        pi1_cur_pred_mode = ps_cur_mb_info->ps_curmb->pi1_intrapredmodes;
        pc_topPredMode = ps_cur_mb_info->ps_top_mb->pi1_intrapredmodes;
 /*
         if(u1_mbaff)
         {
         pi1_cur_pred_mode += (u2_mbx << 2);
         pc_topPredMode = pi1_cur_pred_mode + ps_cur_mb_info->i1_offset;
         pi1_cur_pred_mode += (u1_topmb) ? 0: 4;
         }
         */
 if(u1_top_available)
 {
 if(ps_top_mb->u1_mb_type == I_4x4_MB)
 {
 *(WORD32*)pi1_cur_pred_mode = *(WORD32*)pc_topPredMode;
 }
 else
 {
 *(WORD32*)pi1_cur_pred_mode =
 (uc_useTopMB) ? DC_DC_DC_DC : NOT_VALID;
 }
 }
 else
 {
 *(WORD32*)pi1_cur_pred_mode = NOT_VALID;
 }

        pu1_top = puc_top - 8;

 /*Left Related initialisations*/
        pi1_left_pred_mode = ps_dec->pi1_left_pred_mode;

 if(!u1_mbaff)
 {
 if(u1_left_available)
 {
 if(ps_left_mb->u1_mb_type != I_4x4_MB)
 {
 *(WORD32*)pi1_left_pred_mode =
 (u2_use_left_mb_pack) ?
                                    DC_DC_DC_DC :
                                                            NOT_VALID;
 }
 }
 else
 {
 *(WORD32*)pi1_left_pred_mode = NOT_VALID;
 }
 }
 else
 {
            UWORD8 u1_curMbfld = ps_cur_mb_info->u1_mb_field_decodingflag;

            UWORD8 u1_leftMbfld = ps_left_mb->u1_mb_fld;

 if((!u1_curMbfld) && (u1_leftMbfld))
 {
                u4_4x4_left_offset = 1;
 }

 if(u1_curMbfld ^ u1_leftMbfld)
 {

 if(u1_topmb
 | ((u1_topmb == 0)
 && ((ps_curmb - 1)->u1_mb_type
 != I_4x4_MB)))

 {
 if(u1_left_available)
 {
 if(ps_left_mb->u1_mb_type != I_4x4_MB)
 {
 if(CHECKBIT(u2_use_left_mb_pack,0) == 0)
 {
 *(WORD32*)pi1_left_pred_mode = NOT_VALID;
 }
 else
 {
 *(WORD32*)pi1_left_pred_mode = DC_DC_DC_DC;
 }
 }
 }
 else
 {
 *(WORD32*)pi1_left_pred_mode = NOT_VALID;
 }

 if(u1_curMbfld)
 {
 if(u1_left_available)
 {
 if((ps_left_mb + 1)->u1_mb_type != I_4x4_MB)
 {
 if(u2_use_left_mb_pack >> 8)
 {
 *(WORD32*)(pi1_left_pred_mode + 4) =
                                                    DC_DC_DC_DC;
 }
 else
 {
 *(WORD32*)(pi1_left_pred_mode + 4) =
                                                    NOT_VALID;
 }
 }
 }
 else
 {
 *(WORD32*)(pi1_left_pred_mode + 4) = NOT_VALID;
 }

                        pi1_left_pred_mode[1] = pi1_left_pred_mode[2];
                        pi1_left_pred_mode[2] = pi1_left_pred_mode[4];
                        pi1_left_pred_mode[3] = pi1_left_pred_mode[6];
 *(WORD32*)(pi1_left_pred_mode + 4) =
 *(WORD32*)pi1_left_pred_mode;
 }
 else
 {
                        pi1_left_pred_mode[7] = pi1_left_pred_mode[3];
                        pi1_left_pred_mode[6] = pi1_left_pred_mode[3];
                        pi1_left_pred_mode[5] = pi1_left_pred_mode[2];
                        pi1_left_pred_mode[4] = pi1_left_pred_mode[2];
                        pi1_left_pred_mode[3] = pi1_left_pred_mode[1];
                        pi1_left_pred_mode[2] = pi1_left_pred_mode[1];
                        pi1_left_pred_mode[1] = pi1_left_pred_mode[0];
 }
 }
                pi1_left_pred_mode += (u1_topmb) ? 0 : 4;
 }
 else
 {
                pi1_left_pred_mode += (u1_topmb) ? 0 : 4;

 if(u1_left_available)
 {
 if(ps_left_mb->u1_mb_type != I_4x4_MB)
 {
 *(WORD32*)pi1_left_pred_mode =
 (u2_use_left_mb_pack) ?
                                        DC_DC_DC_DC :
                                                                NOT_VALID;
 }
 }
 else
 {
 *(WORD32*)pi1_left_pred_mode = NOT_VALID;
 }
 }
 }

 /* One time pointer initialisations*/
        pi2_y_coeff1 = pi2_y_coeff;

 if(u1_use_top_left_mb)
 {
            pu1_top_left = pu1_ytop_left;
 }
 else
 {
            pu1_top_left = NULL;
 }

 /* Scan the sub-blocks in Raster Scan Order */
 for(u1_sub_mb_num = 0; u1_sub_mb_num < 4; u1_sub_mb_num++)
 {
            u1_sub_blk_x = (u1_sub_mb_num & 0x1);
            u1_sub_blk_y = (u1_sub_mb_num >> 1);
            i1_top_pred_mode = pi1_cur_pred_mode[u1_sub_blk_x << 1];
            i1_left_pred_mode = pi1_left_pred_mode[u1_sub_blk_y << 1];

 if(2 == u1_sub_mb_num)
 {
                i1_left_pred_mode = pi1_left_pred_mode[(u1_sub_blk_y << 1)
 + u4_4x4_left_offset];
 }

            u1_use_top_right_mb = (!!CHECKBIT(ui2_top_rt_mask, u1_sub_mb_num));

 /*********** left subblock availability**********/
 if(u1_sub_blk_x)
 {
                u1_is_left_sub_block = 1;
 }
 else
 {
                u1_is_left_sub_block =
 (u1_sub_blk_y < 1) ?
 (CHECKBIT(u2_use_left_mb_pack,
 0)) :
 (u2_use_left_mb_pack >> 8);
 }

 /***************** Top *********************/
 if(u1_sub_blk_y)
 {
                u1_is_top_sub_block = 1;
                pu1_top = /*pu1_luma_pred_buffer*/pu1_luma_rec_buffer - ui_rec_width;
 }
 else
 {
                pu1_top += 8;
 }

 /***************** Left *********************/
 if((u1_sub_blk_x) | (u4_num_pmbair != 0))
 {
                pu1_left = /*pu1_luma_pred_buffer*/pu1_luma_rec_buffer - 1;
                ui2_left_pred_buf_width = ui_rec_width;
 }
 else
 {
                pu1_left = pu1_yleft;
                pu1_yleft += (ui_rec_width << 3);
                ui2_left_pred_buf_width = ui_rec_width;
 }

 /***************** Top Left *********************/
 if(u1_sub_mb_num)
 {
                pu1_top_left = (u1_sub_blk_x) ?
                                pu1_top - 1 : pu1_left - ui_rec_width;

 if((u1_sub_blk_x && (!u1_is_top_sub_block))
 || ((!u1_sub_blk_x) && (!u1_is_left_sub_block)))
 {
                    pu1_top_left = NULL;
 }
 }

 /*---------------------------------------------------------------*/
 /* Calculation of Intra prediction mode                          */
 /*---------------------------------------------------------------*/
            i1_intra_pred = ((i1_left_pred_mode < 0) | (i1_top_pred_mode < 0)) ?
                            DC : MIN(i1_left_pred_mode, i1_top_pred_mode);
 {
                UWORD8 u1_packed_modes = (u1_is_top_sub_block << 1)
 + u1_is_left_sub_block;
                UWORD8 *pu1_intra_err_codes =
 (UWORD8 *)gau1_ih264d_intra_pred_err_code;

 /********************************************************************/
 /* Same intra4x4_pred_mode array is filled with intra4x4_pred_mode  */
 /* for a MB with 8x8 intrapredicition                               */
 /********************************************************************/
                PROFILE_DISABLE_INTRA_PRED()
 if(!pu1_prev_intra4x4_pred_mode_flag[u1_sub_mb_num])
 {
                    i1_intra_pred = pu1_rem_intra4x4_pred_mode[u1_sub_mb_num]

                                     + (pu1_rem_intra4x4_pred_mode[u1_sub_mb_num]
                                                     >= i1_intra_pred);
                 }
                 {
                     UWORD8 u1_err_code = pu1_intra_err_codes[i1_intra_pred];
 
 if((u1_err_code & u1_packed_modes) ^ u1_err_code)
 {
                        i1_intra_pred = 0;
                        ps_dec->i4_error_code = ERROR_INTRAPRED;
 }
 }
 }

 {
                UWORD8 au1_ngbr_pels[25];
                WORD32 ngbr_avail;
                ngbr_avail = u1_is_left_sub_block << 0;
                ngbr_avail |= u1_is_top_sub_block << 2;

 if(pu1_top_left)
                    ngbr_avail |= 1 << 1;

                ngbr_avail |= u1_use_top_right_mb << 3;
                PROFILE_DISABLE_INTRA_PRED()
 {
                    ps_dec->pf_intra_pred_ref_filtering(pu1_left, pu1_top_left,
                                                        pu1_top, au1_ngbr_pels,
                                                        ui2_left_pred_buf_width,
                                                        ngbr_avail);

                    ps_dec->apf_intra_pred_luma_8x8[i1_intra_pred](
                                    au1_ngbr_pels, pu1_luma_rec_buffer, 1,
                                    ui_rec_width,
 ((u1_is_top_sub_block << 2) | u1_is_left_sub_block));
 }
 }

 /* Inverse Transform and Reconstruction */
 if(CHECKBIT(ps_cur_mb_info->u1_cbp, u1_sub_mb_num))
 {
                WORD16 *pi2_scale_matrix_ptr;
                WORD16 ai2_tmp[64];

                pi2_scale_matrix_ptr =
                                ps_dec->s_high_profile.i2_scalinglist8x8[0];
                PROFILE_DISABLE_IQ_IT_RECON()
 {
 if(CHECKBIT(u4_luma_dc_only_cbp, u1_sub_mb_num))
 {
                        ps_dec->pf_iquant_itrans_recon_luma_8x8_dc(
                                        pi2_y_coeff1,
                                        pu1_luma_rec_buffer,
                                        pu1_luma_rec_buffer,
                                        ui_rec_width,
                                        ui_rec_width,
                                        gau1_ih264d_dequant8x8_cavlc[ps_cur_mb_info->u1_qp_rem6],
 (UWORD16 *)pi2_scale_matrix_ptr,
                                        ps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,
                                        NULL);
 }
 else
 {
                        ps_dec->pf_iquant_itrans_recon_luma_8x8(
                                        pi2_y_coeff1,
                                        pu1_luma_rec_buffer,
                                        pu1_luma_rec_buffer,
                                        ui_rec_width,
                                        ui_rec_width,
                                        gau1_ih264d_dequant8x8_cavlc[ps_cur_mb_info->u1_qp_rem6],
 (UWORD16 *)pi2_scale_matrix_ptr,
                                        ps_cur_mb_info->u1_qp_div6, ai2_tmp, 0,
                                        NULL);
 }
 }

 }

 /*---------------------------------------------------------------*/
 /* Update sub block number                                       */
 /*---------------------------------------------------------------*/
            pi2_y_coeff1 += 64;

            pu1_luma_rec_buffer +=
 (u1_sub_blk_x == 1) ?
 (ui_rec_width << 3) - (8 * 1) : 8;

 /*---------------------------------------------------------------*/
 /* Pred mode filled in terms of 4x4 block so replicated in 2     */
 /* locations.                                                    */
 /*---------------------------------------------------------------*/
            pi1_cur_pred_mode[u1_sub_blk_x << 1] = i1_intra_pred;
            pi1_cur_pred_mode[(u1_sub_blk_x << 1) + 1] = i1_intra_pred;
            pi1_left_pred_mode[u1_sub_blk_y << 1] = i1_intra_pred;
            pi1_left_pred_mode[(u1_sub_blk_y << 1) + 1] = i1_intra_pred;
 }
 }
 /* Decode Chroma Block */
    ih264d_unpack_chroma_coeff4x4_mb(ps_dec,
                                     ps_cur_mb_info);
 /*--------------------------------------------------------------------*/
 /* Chroma Blocks decoding                                             */
 /*--------------------------------------------------------------------*/
 {
        UWORD8 u1_intra_chrom_pred_mode;
        UWORD8 u1_chroma_cbp = (UWORD8)(ps_cur_mb_info->u1_cbp >> 4);

 /*--------------------------------------------------------------------*/
 /* Perform Chroma intra prediction                                    */
 /*--------------------------------------------------------------------*/

        u1_intra_chrom_pred_mode = CHROMA_TO_LUMA_INTRA_MODE(
                        ps_cur_mb_info->u1_chroma_pred_mode);

 {
            UWORD8 u1_packed_modes = (u1_top_available << 1)
 + u1_left_available;
            UWORD8 u1_err_code =
 (u1_intra_chrom_pred_mode & 1) ?
                                            u1_intra_chrom_pred_mode :
 (u1_intra_chrom_pred_mode ^ 2);
 if((u1_err_code & u1_packed_modes) ^ u1_err_code)
 {
                u1_intra_chrom_pred_mode = 0;
                ps_dec->i4_error_code = ERROR_INTRAPRED;
 }
 }

 /* CHANGED CODE */
 if(u1_chroma_cbp != CBPC_ALLZERO)
 {
            UWORD16 u2_chroma_csbp =
 (u1_chroma_cbp == CBPC_ACZERO) ?
 0 : ps_cur_mb_info->u2_chroma_csbp;
            UWORD32 u4_scale_u;
            UWORD32 u4_scale_v;

 {
                UWORD16 au2_ngbr_pels[33];
                UWORD8 *pu1_ngbr_pels = (UWORD8 *)au2_ngbr_pels;
                UWORD16 *pu2_left_uv;
                UWORD16 *pu2_topleft_uv;
                WORD32 use_left1 = (u2_use_left_mb_pack & 0x0ff);
                WORD32 use_left2 = (u2_use_left_mb_pack & 0xff00) >> 8;

                pu2_left_uv = (UWORD16 *)pu1_uleft;
                pu2_topleft_uv = (UWORD16 *)pu1_u_top_left;
 /* Get neighbour pixels */
 /* left pels */
 if(u2_use_left_mb_pack)
 {
                    WORD32 i;
 if(use_left1)
 {
 for(i = 0; i < 4; i++)
                            au2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i
 * u4_recwidth_cr / YUV420SP_FACTOR];
 }
 else
 {
                        memset(au2_ngbr_pels + 4, 0, 4 * sizeof(UWORD16));
 }

 if(use_left2)
 {
 for(i = 4; i < 8; i++)
                            au2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i
 * u4_recwidth_cr / YUV420SP_FACTOR];
 }
 else
 {
                        memset(au2_ngbr_pels, 0, 4 * sizeof(UWORD16));
 }
 }
 else
 {
                    memset(au2_ngbr_pels, 0, 8 * sizeof(UWORD16));
 }

 /* top left pels */
                au2_ngbr_pels[8] = *pu2_topleft_uv;

 /* top pels */
 if(uc_useTopMB)
 {
                    memcpy(au2_ngbr_pels + 8 + 1, pu1_top_u,
 8 * sizeof(UWORD16));
 }
 else
 {
                    memset(au2_ngbr_pels + 8 + 1, 0, 8 * sizeof(UWORD16));
 }

                PROFILE_DISABLE_INTRA_PRED()
                ps_dec->apf_intra_pred_chroma[u1_intra_chrom_pred_mode](
                                pu1_ngbr_pels,
                                pu1_mb_cb_rei1_buffer,
 1,
                                u4_recwidth_cr,
 ((uc_useTopMB << 2) | (use_left2 << 4)
 | use_left1));
 }
            u4_scale_u = ps_cur_mb_info->u1_qpc_div6;
            u4_scale_v = ps_cur_mb_info->u1_qpcr_div6;
            pi2_y_coeff = ps_dec->pi2_coeff_data;

 {
                UWORD32 i;
                WORD16 ai2_tmp[16];
 for(i = 0; i < 4; i++)
 {
                    WORD16 *pi2_level = pi2_y_coeff + (i << 4);
                    UWORD8 *pu1_pred_sblk = pu1_mb_cb_rei1_buffer
 + ((i & 0x1) * BLK_SIZE * YUV420SP_FACTOR)
 + (i >> 1) * (u4_recwidth_cr << 2);
                    PROFILE_DISABLE_IQ_IT_RECON()
 {
 if(CHECKBIT(u2_chroma_csbp, i))
 {
                            ps_dec->pf_iquant_itrans_recon_chroma_4x4(
                                            pi2_level,
                                            pu1_pred_sblk,
                                            pu1_pred_sblk,
                                            u4_recwidth_cr,
                                            u4_recwidth_cr,
                                            gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpc_rem6],
 (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[1],
                                            u4_scale_u, ai2_tmp, pi2_level);
 }
 else if(pi2_level[0] != 0)
 {
                            ps_dec->pf_iquant_itrans_recon_chroma_4x4_dc(
                                            pi2_level,
                                            pu1_pred_sblk,
                                            pu1_pred_sblk,
                                            u4_recwidth_cr,
                                            u4_recwidth_cr,
                                            gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpc_rem6],
 (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[1],
                                            u4_scale_u, ai2_tmp, pi2_level);
 }
 }

 }
 }

            pi2_y_coeff += MB_CHROM_SIZE;
            u2_chroma_csbp = u2_chroma_csbp >> 4;
 {
                UWORD32 i;
                WORD16 ai2_tmp[16];
 for(i = 0; i < 4; i++)
 {
                    WORD16 *pi2_level = pi2_y_coeff + (i << 4);
                    UWORD8 *pu1_pred_sblk = pu1_mb_cb_rei1_buffer + 1
 + ((i & 0x1) * BLK_SIZE * YUV420SP_FACTOR)
 + (i >> 1) * (u4_recwidth_cr << 2);
                    PROFILE_DISABLE_IQ_IT_RECON()
 {
 if(CHECKBIT(u2_chroma_csbp, i))
 {
                            ps_dec->pf_iquant_itrans_recon_chroma_4x4(
                                            pi2_level,
                                            pu1_pred_sblk,
                                            pu1_pred_sblk,
                                            u4_recwidth_cr,
                                            u4_recwidth_cr,
                                            gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpcr_rem6],
 (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[2],
                                            u4_scale_v, ai2_tmp, pi2_level);
 }
 else if(pi2_level[0] != 0)
 {
                            ps_dec->pf_iquant_itrans_recon_chroma_4x4_dc(
                                            pi2_level,
                                            pu1_pred_sblk,
                                            pu1_pred_sblk,
                                            u4_recwidth_cr,
                                            u4_recwidth_cr,
                                            gau2_ih264_iquant_scale_4x4[ps_cur_mb_info->u1_qpcr_rem6],
 (UWORD16 *)ps_dec->s_high_profile.i2_scalinglist4x4[2],
                                            u4_scale_v, ai2_tmp, pi2_level);
 }
 }
 }
 }

 }
 else
 {
 /* If no inverse transform is needed, pass recon buffer pointer */
 /* to Intraprediction module instead of pred buffer pointer     */
 {
                UWORD16 au2_ngbr_pels[33];
                UWORD8 *pu1_ngbr_pels = (UWORD8 *)au2_ngbr_pels;
                UWORD16 *pu2_left_uv;
                UWORD16 *pu2_topleft_uv;
                WORD32 use_left1 = (u2_use_left_mb_pack & 0x0ff);
                WORD32 use_left2 = (u2_use_left_mb_pack & 0xff00) >> 8;

                pu2_topleft_uv = (UWORD16 *)pu1_u_top_left;
                pu2_left_uv = (UWORD16 *)pu1_uleft;

 /* Get neighbour pixels */
 /* left pels */
 if(u2_use_left_mb_pack)
 {
                    WORD32 i;
 if(use_left1)
 {
 for(i = 0; i < 4; i++)
                            au2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i
 * u4_recwidth_cr / YUV420SP_FACTOR];
 }
 else
 {
                        memset(au2_ngbr_pels + 4, 0, 4 * sizeof(UWORD16));
 }

 if(use_left2)
 {
 for(i = 4; i < 8; i++)
                            au2_ngbr_pels[8 - 1 - i] = pu2_left_uv[i
 * u4_recwidth_cr / YUV420SP_FACTOR];
 }
 else
 {
                        memset(au2_ngbr_pels, 0, 4 * sizeof(UWORD16));
 }

 }
 else
 {
                    memset(au2_ngbr_pels, 0, 8 * sizeof(UWORD16));
 }

 /* top left pels */
                au2_ngbr_pels[8] = *pu2_topleft_uv;

 /* top pels */
 if(uc_useTopMB)
 {
                    memcpy(au2_ngbr_pels + 8 + 1, pu1_top_u,
 8 * sizeof(UWORD16));
 }
 else
 {
                    memset(au2_ngbr_pels + 8 + 1, 0, 8 * sizeof(UWORD16));
 }

                PROFILE_DISABLE_INTRA_PRED()
                ps_dec->apf_intra_pred_chroma[u1_intra_chrom_pred_mode](
                                pu1_ngbr_pels,
                                pu1_mb_cb_rei1_buffer,
 1,
                                u4_recwidth_cr,
 ((uc_useTopMB << 2) | (use_left2 << 4)
 | use_left1));
 }

 }

 }
 return OK;
}
",agree
CVE-2017-12898,"parserep(netdissect_options *ndo,
         register const struct sunrpc_msg *rp, register u_int length)
{
	register const uint32_t *dp;
	u_int len;
	enum sunrpc_accept_stat astat;

	/*
	 * Portability note:
	 * Here we find the address of the ar_verf credentials.
	 * Originally, this calculation was
	 *	dp = (uint32_t *)&rp->rm_reply.rp_acpt.ar_verf
	 * On the wire, the rp_acpt field starts immediately after
	 * the (32 bit) rp_stat field.  However, rp_acpt (which is a
	 * ""struct accepted_reply"") contains a ""struct opaque_auth"",
	 * whose internal representation contains a pointer, so on a
	 * 64-bit machine the compiler inserts 32 bits of padding
	 * before rp->rm_reply.rp_acpt.ar_verf.  So, we cannot use
	 * the internal representation to parse the on-the-wire
	 * representation.  Instead, we skip past the rp_stat field,
	 * which is an ""enum"" and so occupies one 32-bit word.
	 */
	dp = ((const uint32_t *)&rp->rm_reply) + 1;
	ND_TCHECK(dp[1]);
	len = EXTRACT_32BITS(&dp[1]);
	if (len >= length)
		return (NULL);
	/*
 	 * skip past the ar_verf credentials.
 	 */
 	dp += (len + (2*sizeof(uint32_t) + 3)) / sizeof(uint32_t);
	ND_TCHECK2(dp[0], 0);
 
 	/*
 	 * now we can check the ar_stat field
 	 */
 	astat = (enum sunrpc_accept_stat) EXTRACT_32BITS(dp);
 	if (astat != SUNRPC_SUCCESS) {
 		ND_PRINT((ndo, "" %s"", tok2str(sunrpc_str, ""ar_stat %d"", astat)));
		nfserr = 1;		/* suppress trunc string */
		return (NULL);
	}
	/* successful return */
	ND_TCHECK2(*dp, sizeof(astat));
	return ((const uint32_t *) (sizeof(astat) + ((const char *)dp)));
trunc:
	return (0);
}
",agree
CVE-2017-5110,"const service_manager::Manifest& GetChromeContentBrowserOverlayManifest() {
  static base::NoDestructor<service_manager::Manifest> manifest {
    service_manager::ManifestBuilder()
        .ExposeCapability(""gpu"",
                          service_manager::Manifest::InterfaceList<
                              metrics::mojom::CallStackProfileCollector>())
        .ExposeCapability(""renderer"",
                          service_manager::Manifest::InterfaceList<
                              chrome::mojom::AvailableOfflineContentProvider,
                              chrome::mojom::CacheStatsRecorder,
                              chrome::mojom::NetBenchmarking,
                              data_reduction_proxy::mojom::DataReductionProxy,
                              metrics::mojom::CallStackProfileCollector,
#if defined(OS_WIN)
                              mojom::ModuleEventSink,
#endif
                              rappor::mojom::RapporRecorder,
                              safe_browsing::mojom::SafeBrowsing>())
        .RequireCapability(""ash"", ""system_ui"")
        .RequireCapability(""ash"", ""test"")
        .RequireCapability(""ash"", ""display"")
        .RequireCapability(""assistant"", ""assistant"")
        .RequireCapability(""assistant_audio_decoder"", ""assistant:audio_decoder"")
        .RequireCapability(""chrome"", ""input_device_controller"")
        .RequireCapability(""chrome_printing"", ""converter"")
        .RequireCapability(""cups_ipp_parser"", ""ipp_parser"")
        .RequireCapability(""device"", ""device:fingerprint"")
        .RequireCapability(""device"", ""device:geolocation_config"")
        .RequireCapability(""device"", ""device:geolocation_control"")
        .RequireCapability(""device"", ""device:ip_geolocator"")
        .RequireCapability(""ime"", ""input_engine"")
        .RequireCapability(""mirroring"", ""mirroring"")
        .RequireCapability(""nacl_broker"", ""browser"")
        .RequireCapability(""nacl_loader"", ""browser"")
        .RequireCapability(""noop"", ""noop"")
        .RequireCapability(""patch"", ""patch_file"")
        .RequireCapability(""preferences"", ""pref_client"")
        .RequireCapability(""preferences"", ""pref_control"")
        .RequireCapability(""profile_import"", ""import"")
        .RequireCapability(""removable_storage_writer"",
                           ""removable_storage_writer"")
        .RequireCapability(""secure_channel"", ""secure_channel"")
        .RequireCapability(""ui"", ""ime_registrar"")
        .RequireCapability(""ui"", ""input_device_controller"")
        .RequireCapability(""ui"", ""window_manager"")
        .RequireCapability(""unzip"", ""unzip_file"")
        .RequireCapability(""util_win"", ""util_win"")
        .RequireCapability(""xr_device_service"", ""xr_device_provider"")
        .RequireCapability(""xr_device_service"", ""xr_device_test_hook"")
#if defined(OS_CHROMEOS)
        .RequireCapability(""multidevice_setup"", ""multidevice_setup"")
#endif
        .ExposeInterfaceFilterCapability_Deprecated(
            ""navigation:frame"", ""renderer"",
            service_manager::Manifest::InterfaceList<
                autofill::mojom::AutofillDriver,
                autofill::mojom::PasswordManagerDriver,
                chrome::mojom::OfflinePageAutoFetcher,
#if defined(OS_CHROMEOS)
                 chromeos_camera::mojom::CameraAppHelper,
                 chromeos::cellular_setup::mojom::CellularSetup,
                 chromeos::crostini_installer::mojom::PageHandlerFactory,
                chromeos::crostini_upgrader::mojom::PageHandlerFactory,
                 chromeos::ime::mojom::InputEngineManager,
                 chromeos::machine_learning::mojom::PageHandler,
                 chromeos::media_perception::mojom::MediaPerception,
                chromeos::multidevice_setup::mojom::MultiDeviceSetup,
                chromeos::multidevice_setup::mojom::PrivilegedHostDeviceSetter,
                chromeos::network_config::mojom::CrosNetworkConfig,
                cros::mojom::CameraAppDeviceProvider,
#endif
                contextual_search::mojom::ContextualSearchJsApiService,
#if BUILDFLAG(ENABLE_EXTENSIONS)
                extensions::KeepAlive,
#endif
                media::mojom::MediaEngagementScoreDetailsProvider,
                media_router::mojom::MediaRouter,
                page_load_metrics::mojom::PageLoadMetrics,
                translate::mojom::ContentTranslateDriver,

                downloads::mojom::PageHandlerFactory,
                feed_internals::mojom::PageHandler,
                new_tab_page::mojom::PageHandlerFactory,
#if defined(OS_ANDROID)
                explore_sites_internals::mojom::PageHandler,
#else
                app_management::mojom::PageHandlerFactory,
#endif
#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
    defined(OS_CHROMEOS)
                discards::mojom::DetailsProvider, discards::mojom::GraphDump,
#endif
#if defined(OS_CHROMEOS)
                add_supervision::mojom::AddSupervisionHandler,
#endif
                mojom::BluetoothInternalsHandler,
                mojom::InterventionsInternalsPageHandler,
                mojom::OmniboxPageHandler, mojom::ResetPasswordHandler,
                mojom::SiteEngagementDetailsProvider,
                mojom::UsbInternalsPageHandler,
                snippets_internals::mojom::PageHandlerFactory>())
        .PackageService(prefs::GetManifest())
#if defined(OS_CHROMEOS)
        .PackageService(chromeos::multidevice_setup::GetManifest())
#endif  // defined(OS_CHROMEOS)
        .Build()
  };
  return *manifest;
}
",agree
CVE-2017-15394,"std::set<std::string> GetDistinctHosts(const URLPatternSet& host_patterns,
                                       bool include_rcd,
                                       bool exclude_file_scheme) {
  typedef base::StringPairs HostVector;
  HostVector hosts_best_rcd;
  for (const URLPattern& pattern : host_patterns) {
    if (exclude_file_scheme && pattern.scheme() == url::kFileScheme)
       continue;
 
     std::string host = pattern.host();
 
     if (pattern.match_subdomains())
      host = ""*."" + host;


    std::string rcd;
    size_t reg_len =
        net::registry_controlled_domains::PermissiveGetHostRegistryLength(
            host, net::registry_controlled_domains::EXCLUDE_UNKNOWN_REGISTRIES,
            net::registry_controlled_domains::EXCLUDE_PRIVATE_REGISTRIES);
    if (reg_len && reg_len != std::string::npos) {
      if (include_rcd)  // else leave rcd empty
        rcd = host.substr(host.size() - reg_len);
      host = host.substr(0, host.size() - reg_len);
    }

    HostVector::iterator it = hosts_best_rcd.begin();
    for (; it != hosts_best_rcd.end(); ++it) {
      if (it->first == host)
        break;
    }
    if (it != hosts_best_rcd.end()) {
      if (include_rcd && RcdBetterThan(rcd, it->second))
        it->second = rcd;
    } else {  // Previously unseen host, append it.
      hosts_best_rcd.push_back(std::make_pair(host, rcd));
    }
  }

  std::set<std::string> distinct_hosts;
  for (const auto& host_rcd : hosts_best_rcd)
    distinct_hosts.insert(host_rcd.first + host_rcd.second);
  return distinct_hosts;
}
",agree
CVE-2014-0077,"static void handle_rx(struct vhost_net *net)
{
	struct vhost_net_virtqueue *nvq = &net->vqs[VHOST_NET_VQ_RX];
	struct vhost_virtqueue *vq = &nvq->vq;
	unsigned uninitialized_var(in), log;
	struct vhost_log *vq_log;
	struct msghdr msg = {
		.msg_name = NULL,
		.msg_namelen = 0,
		.msg_control = NULL, /* FIXME: get and handle RX aux data. */
		.msg_controllen = 0,
		.msg_iov = vq->iov,
		.msg_flags = MSG_DONTWAIT,
	};
	struct virtio_net_hdr_mrg_rxbuf hdr = {
		.hdr.flags = 0,
		.hdr.gso_type = VIRTIO_NET_HDR_GSO_NONE
	};
	size_t total_len = 0;
	int err, mergeable;
	s16 headcount;
	size_t vhost_hlen, sock_hlen;
	size_t vhost_len, sock_len;
	struct socket *sock;

	mutex_lock(&vq->mutex);
	sock = vq->private_data;
	if (!sock)
		goto out;
	vhost_disable_notify(&net->dev, vq);

	vhost_hlen = nvq->vhost_hlen;
	sock_hlen = nvq->sock_hlen;

	vq_log = unlikely(vhost_has_feature(&net->dev, VHOST_F_LOG_ALL)) ?
		vq->log : NULL;
	mergeable = vhost_has_feature(&net->dev, VIRTIO_NET_F_MRG_RXBUF);

	while ((sock_len = peek_head_len(sock->sk))) {
		sock_len += sock_hlen;
		vhost_len = sock_len + vhost_hlen;
		headcount = get_rx_bufs(vq, vq->heads, vhost_len,
					&in, vq_log, &log,
					likely(mergeable) ? UIO_MAXIOV : 1);
 		/* On error, stop handling until the next kick. */
 		if (unlikely(headcount < 0))
 			break;
 		/* OK, now we need to know about added descriptors. */
 		if (!headcount) {
 			if (unlikely(vhost_enable_notify(&net->dev, vq))) {
				/* They have slipped one in as we were
				 * doing that: check again. */
				vhost_disable_notify(&net->dev, vq);
				continue;
			}
			/* Nothing new?  Wait for eventfd to tell us
			 * they refilled. */
			break;
		}
		/* We don't need to be notified again. */
		if (unlikely((vhost_hlen)))
			/* Skip header. TODO: support TSO. */
			move_iovec_hdr(vq->iov, nvq->hdr, vhost_hlen, in);
		else
			/* Copy the header for use in VIRTIO_NET_F_MRG_RXBUF:
			 * needed because recvmsg can modify msg_iov. */
			copy_iovec_hdr(vq->iov, nvq->hdr, sock_hlen, in);
		msg.msg_iovlen = in;
		err = sock->ops->recvmsg(NULL, sock, &msg,
					 sock_len, MSG_DONTWAIT | MSG_TRUNC);
		/* Userspace might have consumed the packet meanwhile:
		 * it's not supposed to do this usually, but might be hard
		 * to prevent. Discard data we got (if any) and keep going. */
		if (unlikely(err != sock_len)) {
			pr_debug(""Discarded rx packet: ""
				 "" len %d, expected %zd\n"", err, sock_len);
			vhost_discard_vq_desc(vq, headcount);
			continue;
		}
		if (unlikely(vhost_hlen) &&
		    memcpy_toiovecend(nvq->hdr, (unsigned char *)&hdr, 0,
				      vhost_hlen)) {
			vq_err(vq, ""Unable to write vnet_hdr at addr %p\n"",
			       vq->iov->iov_base);
			break;
		}
		/* TODO: Should check and handle checksum. */
		if (likely(mergeable) &&
		    memcpy_toiovecend(nvq->hdr, (unsigned char *)&headcount,
				      offsetof(typeof(hdr), num_buffers),
				      sizeof hdr.num_buffers)) {
			vq_err(vq, ""Failed num_buffers write"");
			vhost_discard_vq_desc(vq, headcount);
			break;
		}
		vhost_add_used_and_signal_n(&net->dev, vq, vq->heads,
					    headcount);
		if (unlikely(vq_log))
			vhost_log_write(vq, vq_log, log, vhost_len);
		total_len += vhost_len;
		if (unlikely(total_len >= VHOST_NET_WEIGHT)) {
			vhost_poll_queue(&vq->poll);
			break;
		}
	}
out:
	mutex_unlock(&vq->mutex);
}
",agree
CVE-2016-5771,"PHP_MINIT_FUNCTION(spl_array)
{
	REGISTER_SPL_STD_CLASS_EX(ArrayObject, spl_array_object_new, spl_funcs_ArrayObject);
	REGISTER_SPL_IMPLEMENTS(ArrayObject, Aggregate);
	REGISTER_SPL_IMPLEMENTS(ArrayObject, ArrayAccess);
	REGISTER_SPL_IMPLEMENTS(ArrayObject, Serializable);
	REGISTER_SPL_IMPLEMENTS(ArrayObject, Countable);
	memcpy(&spl_handler_ArrayObject, zend_get_std_object_handlers(), sizeof(zend_object_handlers));

	spl_handler_ArrayObject.clone_obj = spl_array_object_clone;
	spl_handler_ArrayObject.read_dimension = spl_array_read_dimension;
	spl_handler_ArrayObject.write_dimension = spl_array_write_dimension;
	spl_handler_ArrayObject.unset_dimension = spl_array_unset_dimension;
	spl_handler_ArrayObject.has_dimension = spl_array_has_dimension;
	spl_handler_ArrayObject.count_elements = spl_array_object_count_elements;
 
 	spl_handler_ArrayObject.get_properties = spl_array_get_properties;
 	spl_handler_ArrayObject.get_debug_info = spl_array_get_debug_info;
 	spl_handler_ArrayObject.read_property = spl_array_read_property;
 	spl_handler_ArrayObject.write_property = spl_array_write_property;
 	spl_handler_ArrayObject.get_property_ptr_ptr = spl_array_get_property_ptr_ptr;
	spl_handler_ArrayObject.has_property = spl_array_has_property;
	spl_handler_ArrayObject.unset_property = spl_array_unset_property;

	spl_handler_ArrayObject.compare_objects = spl_array_compare_objects;

	REGISTER_SPL_STD_CLASS_EX(ArrayIterator, spl_array_object_new, spl_funcs_ArrayIterator);
	REGISTER_SPL_IMPLEMENTS(ArrayIterator, Iterator);
	REGISTER_SPL_IMPLEMENTS(ArrayIterator, ArrayAccess);
	REGISTER_SPL_IMPLEMENTS(ArrayIterator, SeekableIterator);
	REGISTER_SPL_IMPLEMENTS(ArrayIterator, Serializable);
	REGISTER_SPL_IMPLEMENTS(ArrayIterator, Countable);
	memcpy(&spl_handler_ArrayIterator, &spl_handler_ArrayObject, sizeof(zend_object_handlers));
	spl_ce_ArrayIterator->get_iterator = spl_array_get_iterator;

	REGISTER_SPL_SUB_CLASS_EX(RecursiveArrayIterator, ArrayIterator, spl_array_object_new, spl_funcs_RecursiveArrayIterator);
	REGISTER_SPL_IMPLEMENTS(RecursiveArrayIterator, RecursiveIterator);
	spl_ce_RecursiveArrayIterator->get_iterator = spl_array_get_iterator;

	REGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   ""STD_PROP_LIST"",    SPL_ARRAY_STD_PROP_LIST);
	REGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   ""ARRAY_AS_PROPS"",   SPL_ARRAY_ARRAY_AS_PROPS);

	REGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, ""STD_PROP_LIST"",    SPL_ARRAY_STD_PROP_LIST);
	REGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, ""ARRAY_AS_PROPS"",   SPL_ARRAY_ARRAY_AS_PROPS);

	REGISTER_SPL_CLASS_CONST_LONG(RecursiveArrayIterator, ""CHILD_ARRAYS_ONLY"", SPL_ARRAY_CHILD_ARRAYS_ONLY);

	return SUCCESS;
}
",agree
CVE-2016-5355,"parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,
    int *err, gchar **err_info)
{
 	union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;
 	char	line[TOSHIBA_LINE_LENGTH];
 	int	num_items_scanned;
	int	pkt_len, pktnum, hr, min, sec, csec;
 	char	channel[10], direction[10];
 	int	i, hex_lines;
 	guint8	*pd;

	/* Our file pointer should be on the line containing the
	 * summary information for a packet. Read in that line and
	 * extract the useful information
	 */
	if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {
		*err = file_error(fh, err_info);
		if (*err == 0) {
			*err = WTAP_ERR_SHORT_READ;
		}
		return FALSE;
	}

	/* Find text in line after ""[No."". Limit the length of the
	 * two strings since we have fixed buffers for channel[] and
	 * direction[] */
	num_items_scanned = sscanf(line, ""%9d] %2d:%2d:%2d.%9d %9s %9s"",
			&pktnum, &hr, &min, &sec, &csec, channel, direction);

	if (num_items_scanned != 7) {
		*err = WTAP_ERR_BAD_FILE;
		*err_info = g_strdup(""toshiba: record header isn't valid"");
		return FALSE;
	}

	/* Scan lines until we find the OFFSET line. In a ""telnet"" trace,
	 * this will be the next line. But if you save your telnet session
	 * to a file from within a Windows-based telnet client, it may
	 * put in line breaks at 80 columns (or however big your ""telnet"" box
	 * is). CRT (a Windows telnet app from VanDyke) does this.
	 * Here we assume that 80 columns will be the minimum size, and that
	 * the OFFSET line is not broken in the middle. It's the previous
	 * line that is normally long and can thus be broken at column 80.
	 */
	do {
		if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {
			*err = file_error(fh, err_info);
			if (*err == 0) {
				*err = WTAP_ERR_SHORT_READ;
			}
			return FALSE;
		}

		/* Check for ""OFFSET 0001-0203"" at beginning of line */
		line[16] = '\0';
 
 	} while (strcmp(line, ""OFFSET 0001-0203"") != 0);
 
	num_items_scanned = sscanf(line+64, ""LEN=%9d"", &pkt_len);
 	if (num_items_scanned != 1) {
 		*err = WTAP_ERR_BAD_FILE;
 		*err_info = g_strdup(""toshiba: OFFSET line doesn't have valid LEN item"");
 		return FALSE;
 	}
 
 	phdr->rec_type = REC_TYPE_PACKET;
 	phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;
	phdr->ts.secs = hr * 3600 + min * 60 + sec;
	phdr->ts.nsecs = csec * 10000000;
	phdr->caplen = pkt_len;
	phdr->len = pkt_len;

	switch (channel[0]) {
		case 'B':
			phdr->pkt_encap = WTAP_ENCAP_ISDN;
			pseudo_header->isdn.uton = (direction[0] == 'T');
			pseudo_header->isdn.channel = (guint8)
			    strtol(&channel[1], NULL, 10);
			break;

		case 'D':
			phdr->pkt_encap = WTAP_ENCAP_ISDN;
			pseudo_header->isdn.uton = (direction[0] == 'T');
			pseudo_header->isdn.channel = 0;
			break;

		default:
			phdr->pkt_encap = WTAP_ENCAP_ETHERNET;
			/* XXX - is there an FCS in the frame? */
			pseudo_header->eth.fcs_len = -1;
			break;
 	}
 
 	/* Make sure we have enough room for the packet */
	ws_buffer_assure_space(buf, TOSHIBA_MAX_PACKET_LEN);
 	pd = ws_buffer_start_ptr(buf);
 
 	/* Calculate the number of hex dump lines, each
	 * containing 16 bytes of data */
	hex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);

	for (i = 0; i < hex_lines; i++) {
		if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {
			*err = file_error(fh, err_info);
			if (*err == 0) {
				*err = WTAP_ERR_SHORT_READ;
			}
			return FALSE;
		}
		if (!parse_single_hex_dump_line(line, pd, i * 16)) {
			*err = WTAP_ERR_BAD_FILE;
			*err_info = g_strdup(""toshiba: hex dump not valid"");
			return FALSE;
		}
	}
	return TRUE;
}
",agree
CVE-2015-3330,"static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	/* apply_config() needs r in some cases, so allocate server_context early */
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, ""INCLUDED""))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		/* register a cleanup so we clear out the SG(server_context)
		 * after each request. Note: We pass in the pointer to the
		 * server_context in case this is handled by a different thread.
		 */
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		/* Check for xbithack in this case. */
		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	/* Give a 404 if PATH_INFO is used but is explicitly disabled in
	 * the configuration; default behaviour is to accept. */
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	/* handle situations where user turns the engine off */
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex(""script '%s' not found or unable to stat"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex(""attempt to invoke directory '%s' as script"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	/* Setup the CGI variables if this is the main request */
	if (r->main == NULL ||
		/* .. or if the sub-request environment differs from the main-request. */
		r->subprocess_env != r->main->subprocess_env
	) {
		/* setup standard CGI variables */
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		/*
		 * check if coming due to ErrorDocument
		 * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs
		 * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting
		 * PHP instance to handle the request rather then creating a new one.
		*/
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, ""INCLUDED"")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	/* Determine if we need to parse the file or show the source */
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, ""mod_php_memory_usage"",
			apr_psprintf(ctx->r->pool, ""%"" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

	if (!parent_req) {
		php_apache_request_dtor(r TSRMLS_CC);
		ctx->request_processed = 1;
		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
		APR_BRIGADE_INSERT_TAIL(brigade, bucket);

		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
 } zend_end_try();
                }
                apr_brigade_cleanup(brigade);
        } else {
                ctx->r = parent_req;
        }
	return OK;
}
",agree
CVE-2017-3733,"int do_ssl3_write(SSL *s, int type, const unsigned char *buf,
                  unsigned int *pipelens, unsigned int numpipes,
                  int create_empty_fragment)
{
    unsigned char *outbuf[SSL_MAX_PIPELINES], *plen[SSL_MAX_PIPELINES];
    SSL3_RECORD wr[SSL_MAX_PIPELINES];
    int i, mac_size, clear = 0;
    int prefix_len = 0;
    int eivlen;
    size_t align = 0;
    SSL3_BUFFER *wb;
    SSL_SESSION *sess;
    unsigned int totlen = 0;
    unsigned int j;

    for (j = 0; j < numpipes; j++)
        totlen += pipelens[j];
    /*
     * first check if there is a SSL3_BUFFER still being written out.  This
     * will happen with non blocking IO
     */
    if (RECORD_LAYER_write_pending(&s->rlayer))
        return (ssl3_write_pending(s, type, buf, totlen));

    /* If we have an alert to send, lets send it */
    if (s->s3->alert_dispatch) {
        i = s->method->ssl_dispatch_alert(s);
        if (i <= 0)
            return (i);
        /* if it went, fall through and send more stuff */
    }

    if (s->rlayer.numwpipes < numpipes)
        if (!ssl3_setup_write_buffer(s, numpipes, 0))
            return -1;

    if (totlen == 0 && !create_empty_fragment)
        return 0;

    sess = s->session;

    if ((sess == NULL) ||
        (s->enc_write_ctx == NULL) || (EVP_MD_CTX_md(s->write_hash) == NULL)) {
        clear = s->enc_write_ctx ? 0 : 1; /* must be AEAD cipher */
        mac_size = 0;
    } else {
        mac_size = EVP_MD_CTX_size(s->write_hash);
        if (mac_size < 0)
            goto err;
    }

    /*
     * 'create_empty_fragment' is true only when this function calls itself
     */
    if (!clear && !create_empty_fragment && !s->s3->empty_fragment_done) {
        /*
         * countermeasure against known-IV weakness in CBC ciphersuites (see
         * http://www.openssl.org/~bodo/tls-cbc.txt)
         */

        if (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA) {
            /*
             * recursive function call with 'create_empty_fragment' set; this
             * prepares and buffers the data for an empty fragment (these
             * 'prefix_len' bytes are sent out later together with the actual
             * payload)
             */
            unsigned int tmppipelen = 0;

            prefix_len = do_ssl3_write(s, type, buf, &tmppipelen, 1, 1);
            if (prefix_len <= 0)
                goto err;

            if (prefix_len >
                (SSL3_RT_HEADER_LENGTH + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD)) {
                /* insufficient space */
                SSLerr(SSL_F_DO_SSL3_WRITE, ERR_R_INTERNAL_ERROR);
                goto err;
            }
        }

        s->s3->empty_fragment_done = 1;
    }

    if (create_empty_fragment) {
        wb = &s->rlayer.wbuf[0];
#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0
        /*
         * extra fragment would be couple of cipher blocks, which would be
         * multiple of SSL3_ALIGN_PAYLOAD, so if we want to align the real
         * payload, then we can just pretend we simply have two headers.
         */
        align = (size_t)SSL3_BUFFER_get_buf(wb) + 2 * SSL3_RT_HEADER_LENGTH;
        align = SSL3_ALIGN_PAYLOAD - 1 - ((align - 1) % SSL3_ALIGN_PAYLOAD);
#endif
        outbuf[0] = SSL3_BUFFER_get_buf(wb) + align;
        SSL3_BUFFER_set_offset(wb, align);
    } else if (prefix_len) {
        wb = &s->rlayer.wbuf[0];
        outbuf[0] = SSL3_BUFFER_get_buf(wb) + SSL3_BUFFER_get_offset(wb)
            + prefix_len;
    } else {
        for (j = 0; j < numpipes; j++) {
            wb = &s->rlayer.wbuf[j];
#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0
            align = (size_t)SSL3_BUFFER_get_buf(wb) + SSL3_RT_HEADER_LENGTH;
            align = SSL3_ALIGN_PAYLOAD - 1 - ((align - 1) % SSL3_ALIGN_PAYLOAD);
#endif
            outbuf[j] = SSL3_BUFFER_get_buf(wb) + align;
            SSL3_BUFFER_set_offset(wb, align);
        }
    }

    /* Explicit IV length, block ciphers appropriate version flag */
    if (s->enc_write_ctx && SSL_USE_EXPLICIT_IV(s)) {
        int mode = EVP_CIPHER_CTX_mode(s->enc_write_ctx);
        if (mode == EVP_CIPH_CBC_MODE) {
            eivlen = EVP_CIPHER_CTX_iv_length(s->enc_write_ctx);
            if (eivlen <= 1)
                eivlen = 0;
        }
        /* Need explicit part of IV for GCM mode */
        else if (mode == EVP_CIPH_GCM_MODE)
            eivlen = EVP_GCM_TLS_EXPLICIT_IV_LEN;
        else if (mode == EVP_CIPH_CCM_MODE)
            eivlen = EVP_CCM_TLS_EXPLICIT_IV_LEN;
        else
            eivlen = 0;
    } else
        eivlen = 0;

    totlen = 0;
    /* Clear our SSL3_RECORD structures */
    memset(wr, 0, sizeof wr);
    for (j = 0; j < numpipes; j++) {
        /* write the header */
        *(outbuf[j]++) = type & 0xff;
        SSL3_RECORD_set_type(&wr[j], type);

        *(outbuf[j]++) = (s->version >> 8);
        /*
         * Some servers hang if initial client hello is larger than 256 bytes
         * and record version number > TLS 1.0
         */
        if (SSL_get_state(s) == TLS_ST_CW_CLNT_HELLO
            && !s->renegotiate && TLS1_get_version(s) > TLS1_VERSION)
            *(outbuf[j]++) = 0x1;
        else
            *(outbuf[j]++) = s->version & 0xff;

        /* field where we are to write out packet length */
        plen[j] = outbuf[j];
        outbuf[j] += 2;

        /* lets setup the record stuff. */
        SSL3_RECORD_set_data(&wr[j], outbuf[j] + eivlen);
        SSL3_RECORD_set_length(&wr[j], (int)pipelens[j]);
        SSL3_RECORD_set_input(&wr[j], (unsigned char *)&buf[totlen]);
        totlen += pipelens[j];

        /*
         * we now 'read' from wr->input, wr->length bytes into wr->data
         */

        /* first we compress */
        if (s->compress != NULL) {
            if (!ssl3_do_compress(s, &wr[j])) {
                SSLerr(SSL_F_DO_SSL3_WRITE, SSL_R_COMPRESSION_FAILURE);
                goto err;
            }
        } else {
            memcpy(wr[j].data, wr[j].input, wr[j].length);
            SSL3_RECORD_reset_input(&wr[j]);
        }

        /*
         * we should still have the output to wr->data and the input from
         * wr->input.  Length should be wr->length. wr->data still points in the
          * wb->buf
          */
 
        if (!SSL_USE_ETM(s) && mac_size != 0) {
             if (s->method->ssl3_enc->mac(s, &wr[j],
                                          &(outbuf[j][wr[j].length + eivlen]),
                                          1) < 0)
                goto err;
            SSL3_RECORD_add_length(&wr[j], mac_size);
        }

        SSL3_RECORD_set_data(&wr[j], outbuf[j]);
        SSL3_RECORD_reset_input(&wr[j]);

        if (eivlen) {
            /*
             * if (RAND_pseudo_bytes(p, eivlen) <= 0) goto err;
             */
            SSL3_RECORD_add_length(&wr[j], eivlen);
        }
    }

    if (s->method->ssl3_enc->enc(s, wr, numpipes, 1) < 1)
         goto err;
 
     for (j = 0; j < numpipes; j++) {
        if (SSL_USE_ETM(s) && mac_size != 0) {
             if (s->method->ssl3_enc->mac(s, &wr[j],
                                          outbuf[j] + wr[j].length, 1) < 0)
                 goto err;
            SSL3_RECORD_add_length(&wr[j], mac_size);
        }

        /* record length after mac and block padding */
        s2n(SSL3_RECORD_get_length(&wr[j]), plen[j]);

        if (s->msg_callback)
            s->msg_callback(1, 0, SSL3_RT_HEADER, plen[j] - 5, 5, s,
                            s->msg_callback_arg);

        /*
         * we should now have wr->data pointing to the encrypted data, which is
         * wr->length long
         */
        SSL3_RECORD_set_type(&wr[j], type); /* not needed but helps for
                                             * debugging */
        SSL3_RECORD_add_length(&wr[j], SSL3_RT_HEADER_LENGTH);

        if (create_empty_fragment) {
            /*
             * we are in a recursive call; just return the length, don't write
             * out anything here
             */
            if (j > 0) {
                /* We should never be pipelining an empty fragment!! */
                SSLerr(SSL_F_DO_SSL3_WRITE, ERR_R_INTERNAL_ERROR);
                goto err;
            }
            return SSL3_RECORD_get_length(wr);
        }

        /* now let's set up wb */
        SSL3_BUFFER_set_left(&s->rlayer.wbuf[j],
                             prefix_len + SSL3_RECORD_get_length(&wr[j]));
    }

    /*
     * memorize arguments so that ssl3_write_pending can detect bad write
     * retries later
     */
    s->rlayer.wpend_tot = totlen;
    s->rlayer.wpend_buf = buf;
    s->rlayer.wpend_type = type;
    s->rlayer.wpend_ret = totlen;

    /* we now just need to write the buffer */
    return ssl3_write_pending(s, type, buf, totlen);
 err:
    return -1;
}
",agree
CVE-2017-13010,"l_strnstart(const char *tstr1, u_int tl1, const char *str2, u_int l2)
 {
 	if (tl1 > l2)
 		return 0;
 
	return (strncmp(tstr1, str2, tl1) == 0 ? 1 : 0);
}
",agree
CVE-2016-1541,"zip_read_mac_metadata(struct archive_read *a, struct archive_entry *entry,
    struct zip_entry *rsrc)
{
	struct zip *zip = (struct zip *)a->format->data;
	unsigned char *metadata, *mp;
	int64_t offset = archive_filter_bytes(&a->archive, 0);
	size_t remaining_bytes, metadata_bytes;
	ssize_t hsize;
	int ret = ARCHIVE_OK, eof;
 
 	switch(rsrc->compression) {
 	case 0:  /* No compression. */
 #ifdef HAVE_ZLIB_H
 	case 8: /* Deflate compression. */
 #endif
		break;
	default: /* Unsupported compression. */
		/* Return a warning. */
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Unsupported ZIP compression method (%s)"",
		    compression_name(rsrc->compression));
		/* We can't decompress this entry, but we will
		 * be able to skip() it and try the next entry. */
		return (ARCHIVE_WARN);
	}

	if (rsrc->uncompressed_size > (4 * 1024 * 1024)) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Mac metadata is too large: %jd > 4M bytes"",
 		    (intmax_t)rsrc->uncompressed_size);
 		return (ARCHIVE_WARN);
 	}
 
 	metadata = malloc((size_t)rsrc->uncompressed_size);
 	if (metadata == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate memory for Mac metadata"");
		return (ARCHIVE_FATAL);
	}

	if (offset < rsrc->local_header_offset)
		__archive_read_consume(a, rsrc->local_header_offset - offset);
	else if (offset != rsrc->local_header_offset) {
		__archive_read_seek(a, rsrc->local_header_offset, SEEK_SET);
	}

	hsize = zip_get_local_file_header_size(a, 0);
	__archive_read_consume(a, hsize);

	remaining_bytes = (size_t)rsrc->compressed_size;
	metadata_bytes = (size_t)rsrc->uncompressed_size;
	mp = metadata;
	eof = 0;
	while (!eof && remaining_bytes) {
		const unsigned char *p;
		ssize_t bytes_avail;
		size_t bytes_used;

		p = __archive_read_ahead(a, 1, &bytes_avail);
		if (p == NULL) {
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Truncated ZIP file header"");
			ret = ARCHIVE_WARN;
			goto exit_mac_metadata;
		}
		if ((size_t)bytes_avail > remaining_bytes)
 			bytes_avail = remaining_bytes;
 		switch(rsrc->compression) {
 		case 0:  /* No compression. */
 			memcpy(mp, p, bytes_avail);
 			bytes_used = (size_t)bytes_avail;
 			metadata_bytes -= bytes_used;
			mp += bytes_used;
			if (metadata_bytes == 0)
				eof = 1;
			break;
#ifdef HAVE_ZLIB_H
		case 8: /* Deflate compression. */
		{
			int r;

			ret = zip_deflate_init(a, zip);
			if (ret != ARCHIVE_OK)
				goto exit_mac_metadata;
			zip->stream.next_in =
			    (Bytef *)(uintptr_t)(const void *)p;
			zip->stream.avail_in = (uInt)bytes_avail;
			zip->stream.total_in = 0;
			zip->stream.next_out = mp;
			zip->stream.avail_out = (uInt)metadata_bytes;
			zip->stream.total_out = 0;

			r = inflate(&zip->stream, 0);
			switch (r) {
			case Z_OK:
				break;
			case Z_STREAM_END:
				eof = 1;
				break;
			case Z_MEM_ERROR:
				archive_set_error(&a->archive, ENOMEM,
				    ""Out of memory for ZIP decompression"");
				ret = ARCHIVE_FATAL;
				goto exit_mac_metadata;
			default:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""ZIP decompression failed (%d)"", r);
				ret = ARCHIVE_FATAL;
				goto exit_mac_metadata;
			}
			bytes_used = zip->stream.total_in;
			metadata_bytes -= zip->stream.total_out;
			mp += zip->stream.total_out;
			break;
		}
#endif
		default:
			bytes_used = 0;
			break;
		}
		__archive_read_consume(a, bytes_used);
		remaining_bytes -= bytes_used;
	}
	archive_entry_copy_mac_metadata(entry, metadata,
	    (size_t)rsrc->uncompressed_size - metadata_bytes);

exit_mac_metadata:
	__archive_read_seek(a, offset, SEEK_SET);
	zip->decompress_init = 0;
	free(metadata);
	return (ret);
}
",agree
CVE-2018-6140,"void RenderFrameDevToolsAgentHost::UpdateFrameHost(
    RenderFrameHostImpl* frame_host) {
  if (frame_host == frame_host_) {
    if (frame_host && !render_frame_alive_) {
      render_frame_alive_ = true;
      for (auto* inspector : protocol::InspectorHandler::ForAgentHost(this))
        inspector->TargetReloadedAfterCrash();
      MaybeReattachToRenderFrame();
    }
    return;
  }

  if (frame_host && !ShouldCreateDevToolsForHost(frame_host)) {
    DestroyOnRenderFrameGone();
    return;
  }
 
   if (IsAttached())
     RevokePolicy();
   frame_host_ = frame_host;
   agent_ptr_.reset();
   if (!render_frame_alive_) {
     render_frame_alive_ = true;
     for (auto* inspector : protocol::InspectorHandler::ForAgentHost(this))
       inspector->TargetReloadedAfterCrash();
   }
   if (IsAttached()) {
     GrantPolicy();
     for (DevToolsSession* session : sessions()) {
      session->SetRenderer(frame_host ? frame_host->GetProcess()->GetID() : -1,
                           frame_host);
    }
    MaybeReattachToRenderFrame();
  }
}
",agree
CVE-2016-2464,"long Cluster::Parse(long long& pos, long& len) const {
 long status = Load(pos, len);

 if (status < 0)
 return status;

  assert(m_pos >= m_element_start);
  assert(m_timecode >= 0);

 const long long cluster_stop =
 (m_element_size < 0) ? -1 : m_element_start + m_element_size;

 if ((cluster_stop >= 0) && (m_pos >= cluster_stop))
 return 1; // nothing else to do

 IMkvReader* const pReader = m_pSegment->m_pReader;

 long long total, avail;

  status = pReader->Length(&total, &avail);

 if (status < 0) // error
 return status;

  assert((total < 0) || (avail <= total));

  pos = m_pos;

 for (;;) {
 if ((cluster_stop >= 0) && (pos >= cluster_stop))
 break;

 if ((total >= 0) && (pos >= total)) {
 if (m_element_size < 0)
        m_element_size = pos - m_element_start;

 break;
 }


 if ((pos + 1) > avail) {
      len = 1;
 return E_BUFFER_NOT_FULL;
 }

 long long result = GetUIntLength(pReader, pos, len);

 if (result < 0) // error
 return static_cast<long>(result);

 if (result > 0) // weird
 return E_BUFFER_NOT_FULL;

 if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
 return E_FILE_FORMAT_INVALID;

 if ((pos + len) > avail)
 return E_BUFFER_NOT_FULL;

 const long long id = ReadUInt(pReader, pos, len);

 if (id < 0) // error
 return static_cast<long>(id);

 if (id == 0) // weird
 return E_FILE_FORMAT_INVALID;


 if ((id == 0x0F43B675) || (id == 0x0C53BB6B)) { // Cluster or Cues ID
 if (m_element_size < 0)
        m_element_size = pos - m_element_start;

 break;
 }

    pos += len; // consume ID field


 if ((pos + 1) > avail) {
      len = 1;
 return E_BUFFER_NOT_FULL;
 }

    result = GetUIntLength(pReader, pos, len);

 if (result < 0) // error
 return static_cast<long>(result);

 if (result > 0) // weird
 return E_BUFFER_NOT_FULL;

 if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
 return E_FILE_FORMAT_INVALID;

 if ((pos + len) > avail)
 return E_BUFFER_NOT_FULL;

 const long long size = ReadUInt(pReader, pos, len);

 if (size < 0) // error
 return static_cast<long>(size);

 const long long unknown_size = (1LL << (7 * len)) - 1;

 if (size == unknown_size)
 return E_FILE_FORMAT_INVALID;

    pos += len; // consume size field

 if ((cluster_stop >= 0) && (pos > cluster_stop))
 return E_FILE_FORMAT_INVALID;


 if (size == 0) // weird
 continue;

 const long long block_stop = pos + size;

 if (cluster_stop >= 0) {
 if (block_stop > cluster_stop) {
 if ((id == 0x20) || (id == 0x23))
 return E_FILE_FORMAT_INVALID;

        pos = cluster_stop;
 break;
 }
 } else if ((total >= 0) && (block_stop > total)) {
      m_element_size = total - m_element_start;
      pos = total;
 break;
 } else if (block_stop > avail) {
      len = static_cast<long>(size);
 return E_BUFFER_NOT_FULL;
 }

 Cluster* const this_ = const_cast<Cluster*>(this);

 if (id == 0x20) // BlockGroup
 return this_->ParseBlockGroup(size, pos, len);

 if (id == 0x23) // SimpleBlock

       return this_->ParseSimpleBlock(size, pos, len);
 
     pos += size;  // consume payload
    assert((cluster_stop < 0) || (pos <= cluster_stop));
   }
 
   assert(m_element_size > 0);
 
   m_pos = pos;
  assert((cluster_stop < 0) || (m_pos <= cluster_stop));
 
   if (m_entries_count > 0) {
     const long idx = m_entries_count - 1;

 const BlockEntry* const pLast = m_entries[idx];
    assert(pLast);

 const Block* const pBlock = pLast->GetBlock();
    assert(pBlock);

 const long long start = pBlock->m_start;

 if ((total >= 0) && (start > total))
 return -1; // defend against trucated stream

 const long long size = pBlock->m_size;

 const long long stop = start + size;
    assert((cluster_stop < 0) || (stop <= cluster_stop));

 if ((total >= 0) && (stop > total))
 return -1; // defend against trucated stream
 }

 return 1; // no more entries
}
",agree
CVE-2015-8963,"static void perf_event_init_cpu(int cpu)
{
 	struct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);
 
 	mutex_lock(&swhash->hlist_mutex);
	swhash->online = true;
 	if (swhash->hlist_refcount > 0) {
 		struct swevent_hlist *hlist;
 
		hlist = kzalloc_node(sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu));
		WARN_ON(!hlist);
		rcu_assign_pointer(swhash->swevent_hlist, hlist);
	}
	mutex_unlock(&swhash->hlist_mutex);
}
",agree
CVE-2018-6138,"  bool IsAllowed(const scoped_refptr<const Extension>& extension,
                 const GURL& url,
                 PermittedFeature feature,
                 int tab_id) {
    const PermissionsData* permissions_data = extension->permissions_data();
    bool script = permissions_data->CanAccessPage(extension.get(), url, tab_id,
                                                   nullptr) &&
                   permissions_data->CanRunContentScriptOnPage(
                       extension.get(), url, tab_id, nullptr);
    bool capture = HasTabsPermission(extension, tab_id) &&
                   permissions_data->CanCaptureVisiblePage(tab_id, NULL);
     switch (feature) {
       case PERMITTED_SCRIPT_ONLY:
         return script && !capture;
      case PERMITTED_CAPTURE_ONLY:
        return capture && !script;
      case PERMITTED_BOTH:
        return script && capture;
      case PERMITTED_NONE:
        return !script && !capture;
    }
    NOTREACHED();
    return false;
  }
",agree
CVE-2016-4071,"static void php_snmp_error(zval *object, const char *docref, int type, const char *format, ...)
{
	va_list args;
	php_snmp_object *snmp_object = NULL;

	if (object) {
		snmp_object = Z_SNMP_P(object);
		if (type == PHP_SNMP_ERRNO_NOERROR) {
			memset(snmp_object->snmp_errstr, 0, sizeof(snmp_object->snmp_errstr));
		} else {
			va_start(args, format);
			vsnprintf(snmp_object->snmp_errstr, sizeof(snmp_object->snmp_errstr) - 1, format, args);
			va_end(args);
		}
		snmp_object->snmp_errno = type;
	}

	if (type == PHP_SNMP_ERRNO_NOERROR) {
		return;
        }
 
        if (object && (snmp_object->exceptions_enabled & type)) {
               zend_throw_exception_ex(php_snmp_exception_ce, type, snmp_object->snmp_errstr);
        } else {
                va_start(args, format);
                php_verror(docref, """", E_WARNING, format, args);
		va_end(args);
	}
}
",agree
CVE-2015-5589,"PHP_METHOD(Phar, webPhar)
{
	zval *mimeoverride = NULL, *rewrite = NULL;
	char *alias = NULL, *error, *index_php = NULL, *f404 = NULL, *ru = NULL;
	int alias_len = 0, ret, f404_len = 0, free_pathinfo = 0, ru_len = 0;
	char *fname, *path_info, *mime_type = NULL, *entry, *pt;
	const char *basename;
	int fname_len, entry_len, code, index_php_len = 0, not_cgi;
	phar_archive_data *phar = NULL;
	phar_entry_info *info = NULL;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|s!s!saz"", &alias, &alias_len, &index_php, &index_php_len, &f404, &f404_len, &mimeoverride, &rewrite) == FAILURE) {
		return;
	}

	phar_request_initialize(TSRMLS_C);
	fname = (char*)zend_get_executed_filename(TSRMLS_C);
	fname_len = strlen(fname);

	if (phar_open_executed_filename(alias, alias_len, &error TSRMLS_CC) != SUCCESS) {
		if (error) {
			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""%s"", error);
			efree(error);
		}
		return;
	}

	/* retrieve requested file within phar */
	if (!(SG(request_info).request_method && SG(request_info).request_uri && (!strcmp(SG(request_info).request_method, ""GET"") || !strcmp(SG(request_info).request_method, ""POST"")))) {
		return;
	}

#ifdef PHP_WIN32
	fname = estrndup(fname, fname_len);
	phar_unixify_path_separators(fname, fname_len);
#endif
	basename = zend_memrchr(fname, '/', fname_len);

	if (!basename) {
		basename = fname;
	} else {
		++basename;
	}

	if ((strlen(sapi_module.name) == sizeof(""cgi-fcgi"")-1 && !strncmp(sapi_module.name, ""cgi-fcgi"", sizeof(""cgi-fcgi"")-1))
		|| (strlen(sapi_module.name) == sizeof(""fpm-fcgi"")-1 && !strncmp(sapi_module.name, ""fpm-fcgi"", sizeof(""fpm-fcgi"")-1))
		|| (strlen(sapi_module.name) == sizeof(""cgi"")-1 && !strncmp(sapi_module.name, ""cgi"", sizeof(""cgi"")-1))) {

		if (PG(http_globals)[TRACK_VARS_SERVER]) {
			HashTable *_server = Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_SERVER]);
			zval **z_script_name, **z_path_info;

			if (SUCCESS != zend_hash_find(_server, ""SCRIPT_NAME"", sizeof(""SCRIPT_NAME""), (void**)&z_script_name) ||
				IS_STRING != Z_TYPE_PP(z_script_name) ||
				!strstr(Z_STRVAL_PP(z_script_name), basename)) {
				return;
			}

			if (SUCCESS == zend_hash_find(_server, ""PATH_INFO"", sizeof(""PATH_INFO""), (void**)&z_path_info) &&
				IS_STRING == Z_TYPE_PP(z_path_info)) {
				entry_len = Z_STRLEN_PP(z_path_info);
				entry = estrndup(Z_STRVAL_PP(z_path_info), entry_len);
				path_info = emalloc(Z_STRLEN_PP(z_script_name) + entry_len + 1);
				memcpy(path_info, Z_STRVAL_PP(z_script_name), Z_STRLEN_PP(z_script_name));
				memcpy(path_info + Z_STRLEN_PP(z_script_name), entry, entry_len + 1);
				free_pathinfo = 1;
			} else {
				entry_len = 0;
				entry = estrndup("""", 0);
				path_info = Z_STRVAL_PP(z_script_name);
			}

			pt = estrndup(Z_STRVAL_PP(z_script_name), Z_STRLEN_PP(z_script_name));

		} else {
			char *testit;

			testit = sapi_getenv(""SCRIPT_NAME"", sizeof(""SCRIPT_NAME"")-1 TSRMLS_CC);
			if (!(pt = strstr(testit, basename))) {
				efree(testit);
				return;
			}

			path_info = sapi_getenv(""PATH_INFO"", sizeof(""PATH_INFO"")-1 TSRMLS_CC);

			if (path_info) {
				entry = path_info;
				entry_len = strlen(entry);
				spprintf(&path_info, 0, ""%s%s"", testit, path_info);
				free_pathinfo = 1;
			} else {
				path_info = testit;
				free_pathinfo = 1;
				entry = estrndup("""", 0);
				entry_len = 0;
			}

			pt = estrndup(testit, (pt - testit) + (fname_len - (basename - fname)));
		}
		not_cgi = 0;
	} else {
		path_info = SG(request_info).request_uri;

		if (!(pt = strstr(path_info, basename))) {
			/* this can happen with rewrite rules - and we have no idea what to do then, so return */
			return;
		}

		entry_len = strlen(path_info);
		entry_len -= (pt - path_info) + (fname_len - (basename - fname));
		entry = estrndup(pt + (fname_len - (basename - fname)), entry_len);

		pt = estrndup(path_info, (pt - path_info) + (fname_len - (basename - fname)));
		not_cgi = 1;
	}

	if (rewrite) {
		zend_fcall_info fci;
		zend_fcall_info_cache fcc;
		zval *params, *retval_ptr, **zp[1];

		MAKE_STD_ZVAL(params);
		ZVAL_STRINGL(params, entry, entry_len, 1);
		zp[0] = &params;

#if PHP_VERSION_ID < 50300
		if (FAILURE == zend_fcall_info_init(rewrite, &fci, &fcc TSRMLS_CC)) {
#else
		if (FAILURE == zend_fcall_info_init(rewrite, 0, &fci, &fcc, NULL, NULL TSRMLS_CC)) {
#endif
			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar error: invalid rewrite callback"");

			if (free_pathinfo) {
				efree(path_info);
			}

			return;
		}

		fci.param_count = 1;
		fci.params = zp;
#if PHP_VERSION_ID < 50300
		++(params->refcount);
#else
		Z_ADDREF_P(params);
#endif
		fci.retval_ptr_ptr = &retval_ptr;

		if (FAILURE == zend_call_function(&fci, &fcc TSRMLS_CC)) {
			if (!EG(exception)) {
				zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar error: failed to call rewrite callback"");
			}

			if (free_pathinfo) {
				efree(path_info);
			}

			return;
		}

		if (!fci.retval_ptr_ptr || !retval_ptr) {
			if (free_pathinfo) {
				efree(path_info);
			}
			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar error: rewrite callback must return a string or false"");
			return;
		}

		switch (Z_TYPE_P(retval_ptr)) {
#if PHP_VERSION_ID >= 60000
			case IS_UNICODE:
				zval_unicode_to_string(retval_ptr TSRMLS_CC);
				/* break intentionally omitted */
#endif
			case IS_STRING:
				efree(entry);

				if (fci.retval_ptr_ptr != &retval_ptr) {
					entry = estrndup(Z_STRVAL_PP(fci.retval_ptr_ptr), Z_STRLEN_PP(fci.retval_ptr_ptr));
					entry_len = Z_STRLEN_PP(fci.retval_ptr_ptr);
				} else {
					entry = Z_STRVAL_P(retval_ptr);
					entry_len = Z_STRLEN_P(retval_ptr);
				}

				break;
			case IS_BOOL:
				phar_do_403(entry, entry_len TSRMLS_CC);

				if (free_pathinfo) {
					efree(path_info);
				}

				zend_bailout();
				return;
			default:
				efree(retval_ptr);

				if (free_pathinfo) {
					efree(path_info);
				}

				zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar error: rewrite callback must return a string or false"");
				return;
		}
	}

	if (entry_len) {
		phar_postprocess_ru_web(fname, fname_len, &entry, &entry_len, &ru, &ru_len TSRMLS_CC);
	}

	if (!entry_len || (entry_len == 1 && entry[0] == '/')) {
		efree(entry);
		/* direct request */
		if (index_php_len) {
			entry = index_php;
			entry_len = index_php_len;
			if (entry[0] != '/') {
				spprintf(&entry, 0, ""/%s"", index_php);
				++entry_len;
			}
		} else {
			/* assume ""index.php"" is starting point */
			entry = estrndup(""/index.php"", sizeof(""/index.php""));
			entry_len = sizeof(""/index.php"")-1;
		}

		if (FAILURE == phar_get_archive(&phar, fname, fname_len, NULL, 0, NULL TSRMLS_CC) ||
			(info = phar_get_entry_info(phar, entry, entry_len, NULL, 0 TSRMLS_CC)) == NULL) {
			phar_do_404(phar, fname, fname_len, f404, f404_len, entry, entry_len TSRMLS_CC);

			if (free_pathinfo) {
				efree(path_info);
			}

			zend_bailout();
		} else {
			char *tmp = NULL, sa = '\0';
			sapi_header_line ctr = {0};
			ctr.response_code = 301;
			ctr.line_len = sizeof(""HTTP/1.1 301 Moved Permanently"")-1;
			ctr.line = ""HTTP/1.1 301 Moved Permanently"";
			sapi_header_op(SAPI_HEADER_REPLACE, &ctr TSRMLS_CC);

			if (not_cgi) {
				tmp = strstr(path_info, basename) + fname_len;
				sa = *tmp;
				*tmp = '\0';
			}

			ctr.response_code = 0;

			if (path_info[strlen(path_info)-1] == '/') {
				ctr.line_len = spprintf(&(ctr.line), 4096, ""Location: %s%s"", path_info, entry + 1);
			} else {
				ctr.line_len = spprintf(&(ctr.line), 4096, ""Location: %s%s"", path_info, entry);
			}

			if (not_cgi) {
				*tmp = sa;
			}

			if (free_pathinfo) {
				efree(path_info);
			}

			sapi_header_op(SAPI_HEADER_REPLACE, &ctr TSRMLS_CC);
			sapi_send_headers(TSRMLS_C);
			efree(ctr.line);
			zend_bailout();
		}
	}

	if (FAILURE == phar_get_archive(&phar, fname, fname_len, NULL, 0, NULL TSRMLS_CC) ||
		(info = phar_get_entry_info(phar, entry, entry_len, NULL, 0 TSRMLS_CC)) == NULL) {
		phar_do_404(phar, fname, fname_len, f404, f404_len, entry, entry_len TSRMLS_CC);
#ifdef PHP_WIN32
		efree(fname);
#endif
		zend_bailout();
	}

	if (mimeoverride && zend_hash_num_elements(Z_ARRVAL_P(mimeoverride))) {
		const char *ext = zend_memrchr(entry, '.', entry_len);
		zval **val;

		if (ext) {
			++ext;

			if (SUCCESS == zend_hash_find(Z_ARRVAL_P(mimeoverride), ext, strlen(ext)+1, (void **) &val)) {
				switch (Z_TYPE_PP(val)) {
					case IS_LONG:
						if (Z_LVAL_PP(val) == PHAR_MIME_PHP || Z_LVAL_PP(val) == PHAR_MIME_PHPS) {
							mime_type = """";
							code = Z_LVAL_PP(val);
						} else {
							zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""Unknown mime type specifier used, only Phar::PHP, Phar::PHPS and a mime type string are allowed"");
#ifdef PHP_WIN32
							efree(fname);
#endif
							RETURN_FALSE;
						}
						break;
					case IS_STRING:
						mime_type = Z_STRVAL_PP(val);
						code = PHAR_MIME_OTHER;
						break;
					default:
						zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""Unknown mime type specifier used (not a string or int), only Phar::PHP, Phar::PHPS and a mime type string are allowed"");
#ifdef PHP_WIN32
						efree(fname);
#endif
						RETURN_FALSE;
				}
			}
		}
	}

	if (!mime_type) {
		code = phar_file_type(&PHAR_G(mime_types), entry, &mime_type TSRMLS_CC);
	}
	ret = phar_file_action(phar, info, mime_type, code, entry, entry_len, fname, pt, ru, ru_len TSRMLS_CC);
}
/* }}} */

/* {{{ proto void Phar::mungServer(array munglist)
 * Defines a list of up to 4 $_SERVER variables that should be modified for execution
 * to mask the presence of the phar archive.  This should be used in conjunction with
 * Phar::webPhar(), and has no effect otherwise
 * SCRIPT_NAME, PHP_SELF, REQUEST_URI and SCRIPT_FILENAME
 */
PHP_METHOD(Phar, mungServer)
{
	zval *mungvalues;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""a"", &mungvalues) == FAILURE) {
		return;
	}

	if (!zend_hash_num_elements(Z_ARRVAL_P(mungvalues))) {
		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""No values passed to Phar::mungServer(), expecting an array of any of these strings: PHP_SELF, REQUEST_URI, SCRIPT_FILENAME, SCRIPT_NAME"");
		return;
	}

	if (zend_hash_num_elements(Z_ARRVAL_P(mungvalues)) > 4) {
		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""Too many values passed to Phar::mungServer(), expecting an array of any of these strings: PHP_SELF, REQUEST_URI, SCRIPT_FILENAME, SCRIPT_NAME"");
		return;
	}

	phar_request_initialize(TSRMLS_C);

	for (zend_hash_internal_pointer_reset(Z_ARRVAL_P(mungvalues)); SUCCESS == zend_hash_has_more_elements(Z_ARRVAL_P(mungvalues)); zend_hash_move_forward(Z_ARRVAL_P(mungvalues))) {
		zval **data = NULL;

		if (SUCCESS != zend_hash_get_current_data(Z_ARRVAL_P(mungvalues), (void **) &data)) {
			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""unable to retrieve array value in Phar::mungServer()"");
			return;
		}

		if (Z_TYPE_PP(data) != IS_STRING) {
			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""Non-string value passed to Phar::mungServer(), expecting an array of any of these strings: PHP_SELF, REQUEST_URI, SCRIPT_FILENAME, SCRIPT_NAME"");
			return;
		}

		if (Z_STRLEN_PP(data) == sizeof(""PHP_SELF"")-1 && !strncmp(Z_STRVAL_PP(data), ""PHP_SELF"", sizeof(""PHP_SELF"")-1)) {
			PHAR_GLOBALS->phar_SERVER_mung_list |= PHAR_MUNG_PHP_SELF;
		}

		if (Z_STRLEN_PP(data) == sizeof(""REQUEST_URI"")-1) {
			if (!strncmp(Z_STRVAL_PP(data), ""REQUEST_URI"", sizeof(""REQUEST_URI"")-1)) {
				PHAR_GLOBALS->phar_SERVER_mung_list |= PHAR_MUNG_REQUEST_URI;
			}
			if (!strncmp(Z_STRVAL_PP(data), ""SCRIPT_NAME"", sizeof(""SCRIPT_NAME"")-1)) {
				PHAR_GLOBALS->phar_SERVER_mung_list |= PHAR_MUNG_SCRIPT_NAME;
			}
		}

		if (Z_STRLEN_PP(data) == sizeof(""SCRIPT_FILENAME"")-1 && !strncmp(Z_STRVAL_PP(data), ""SCRIPT_FILENAME"", sizeof(""SCRIPT_FILENAME"")-1)) {
			PHAR_GLOBALS->phar_SERVER_mung_list |= PHAR_MUNG_SCRIPT_FILENAME;
		}
	}
}
/* }}} */

/* {{{ proto void Phar::interceptFileFuncs()
 * instructs phar to intercept fopen, file_get_contents, opendir, and all of the stat-related functions
 * and return stat on files within the phar for relative paths
 *
 * Once called, this cannot be reversed, and continue until the end of the request.
 *
 * This allows legacy scripts to be pharred unmodified
 */
PHP_METHOD(Phar, interceptFileFuncs)
{
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	phar_intercept_functions(TSRMLS_C);
}
/* }}} */

/* {{{ proto array Phar::createDefaultStub([string indexfile[, string webindexfile]])
 * Return a stub that can be used to run a phar-based archive without the phar extension
 * indexfile is the CLI startup filename, which defaults to ""index.php"", webindexfile
 * is the web startup filename, and also defaults to ""index.php""
 */
PHP_METHOD(Phar, createDefaultStub)
{
	char *index = NULL, *webindex = NULL, *stub, *error;
	int index_len = 0, webindex_len = 0;
	size_t stub_len;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|ss"", &index, &index_len, &webindex, &webindex_len) == FAILURE) {
		return;
	}

	stub = phar_create_default_stub(index, webindex, &stub_len, &error TSRMLS_CC);

	if (error) {
		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""%s"", error);
		efree(error);
		return;
	}
	RETURN_STRINGL(stub, stub_len, 0);
}
/* }}} */

/* {{{ proto mixed Phar::mapPhar([string alias, [int dataoffset]])
 * Reads the currently executed file (a phar) and registers its manifest */
PHP_METHOD(Phar, mapPhar)
{
	char *alias = NULL, *error;
	int alias_len = 0;
	long dataoffset = 0;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|s!l"", &alias, &alias_len, &dataoffset) == FAILURE) {
		return;
	}

	phar_request_initialize(TSRMLS_C);

	RETVAL_BOOL(phar_open_executed_filename(alias, alias_len, &error TSRMLS_CC) == SUCCESS);

	if (error) {
		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""%s"", error);
		efree(error);
	}
} /* }}} */

/* {{{ proto mixed Phar::loadPhar(string filename [, string alias])
 * Loads any phar archive with an alias */
PHP_METHOD(Phar, loadPhar)
{
	char *fname, *alias = NULL, *error;
	int fname_len, alias_len = 0;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|s!"", &fname, &fname_len, &alias, &alias_len) == FAILURE) {
		return;
	}

	phar_request_initialize(TSRMLS_C);

	RETVAL_BOOL(phar_open_from_filename(fname, fname_len, alias, alias_len, REPORT_ERRORS, NULL, &error TSRMLS_CC) == SUCCESS);

	if (error) {
		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""%s"", error);
		efree(error);
	}
} /* }}} */

/* {{{ proto string Phar::apiVersion()
 * Returns the api version */
PHP_METHOD(Phar, apiVersion)
{
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	RETURN_STRINGL(PHP_PHAR_API_VERSION, sizeof(PHP_PHAR_API_VERSION)-1, 1);
}
/* }}}*/

/* {{{ proto bool Phar::canCompress([int method])
 * Returns whether phar extension supports compression using zlib/bzip2 */
PHP_METHOD(Phar, canCompress)
{
	long method = 0;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|l"", &method) == FAILURE) {
		return;
	}

	phar_request_initialize(TSRMLS_C);
	switch (method) {
	case PHAR_ENT_COMPRESSED_GZ:
		if (PHAR_G(has_zlib)) {
			RETURN_TRUE;
		} else {
			RETURN_FALSE;
		}
	case PHAR_ENT_COMPRESSED_BZ2:
		if (PHAR_G(has_bz2)) {
			RETURN_TRUE;
		} else {
			RETURN_FALSE;
		}
	default:
		if (PHAR_G(has_zlib) || PHAR_G(has_bz2)) {
			RETURN_TRUE;
		} else {
			RETURN_FALSE;
		}
	}
}
/* }}} */

/* {{{ proto bool Phar::canWrite()
 * Returns whether phar extension supports writing and creating phars */
PHP_METHOD(Phar, canWrite)
{
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	RETURN_BOOL(!PHAR_G(readonly));
}
/* }}} */

/* {{{ proto bool Phar::isValidPharFilename(string filename[, bool executable = true])
 * Returns whether the given filename is a valid phar filename */
PHP_METHOD(Phar, isValidPharFilename)
{
	char *fname;
	const char *ext_str;
	int fname_len, ext_len, is_executable;
	zend_bool executable = 1;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|b"", &fname, &fname_len, &executable) == FAILURE) {
		return;
	}

	is_executable = executable;
	RETVAL_BOOL(phar_detect_phar_fname_ext(fname, fname_len, &ext_str, &ext_len, is_executable, 2, 1 TSRMLS_CC) == SUCCESS);
}
/* }}} */

#if HAVE_SPL
/**
 * from spl_directory
 */
static void phar_spl_foreign_dtor(spl_filesystem_object *object TSRMLS_DC) /* {{{ */
{
	phar_archive_data *phar = (phar_archive_data *) object->oth;

	if (!phar->is_persistent) {
		phar_archive_delref(phar TSRMLS_CC);
	}

	object->oth = NULL;
}
/* }}} */

/**
 * from spl_directory
 */
static void phar_spl_foreign_clone(spl_filesystem_object *src, spl_filesystem_object *dst TSRMLS_DC) /* {{{ */
{
	phar_archive_data *phar_data = (phar_archive_data *) dst->oth;

	if (!phar_data->is_persistent) {
		++(phar_data->refcount);
	}
}
/* }}} */

static spl_other_handler phar_spl_foreign_handler = {
	phar_spl_foreign_dtor,
	phar_spl_foreign_clone
};
#endif /* HAVE_SPL */

/* {{{ proto void Phar::__construct(string fname [, int flags [, string alias]])
 * Construct a Phar archive object
 *
 * proto void PharData::__construct(string fname [[, int flags [, string alias]], int file format = Phar::TAR])
 * Construct a PharData archive object
 *
 * This function is used as the constructor for both the Phar and PharData
 * classes, hence the two prototypes above.
 */
PHP_METHOD(Phar, __construct)
{
#if !HAVE_SPL
	zend_throw_exception_ex(zend_exception_get_default(TSRMLS_C), 0 TSRMLS_CC, ""Cannot instantiate Phar object without SPL extension"");
#else
	char *fname, *alias = NULL, *error, *arch = NULL, *entry = NULL, *save_fname;
	int fname_len, alias_len = 0, arch_len, entry_len, is_data;
#if PHP_VERSION_ID < 50300
	long flags = 0;
#else
	long flags = SPL_FILE_DIR_SKIPDOTS|SPL_FILE_DIR_UNIXPATHS;
#endif
	long format = 0;
	phar_archive_object *phar_obj;
	phar_archive_data   *phar_data;
	zval *zobj = getThis(), arg1, arg2;

	phar_obj = (phar_archive_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

	is_data = instanceof_function(Z_OBJCE_P(zobj), phar_ce_data TSRMLS_CC);

	if (is_data) {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|ls!l"", &fname, &fname_len, &flags, &alias, &alias_len, &format) == FAILURE) {
			return;
		}
	} else {
		if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|ls!"", &fname, &fname_len, &flags, &alias, &alias_len) == FAILURE) {
			return;
		}
	}

	if (phar_obj->arc.archive) {
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Cannot call constructor twice"");
		return;
	}

	save_fname = fname;
	if (SUCCESS == phar_split_fname(fname, fname_len, &arch, &arch_len, &entry, &entry_len, !is_data, 2 TSRMLS_CC)) {
		/* use arch (the basename for the archive) for fname instead of fname */
		/* this allows support for RecursiveDirectoryIterator of subdirectories */
#ifdef PHP_WIN32
		phar_unixify_path_separators(arch, arch_len);
#endif
		fname = arch;
		fname_len = arch_len;
#ifdef PHP_WIN32
	} else {
		arch = estrndup(fname, fname_len);
		arch_len = fname_len;
		fname = arch;
		phar_unixify_path_separators(arch, arch_len);
#endif
	}

	if (phar_open_or_create_filename(fname, fname_len, alias, alias_len, is_data, REPORT_ERRORS, &phar_data, &error TSRMLS_CC) == FAILURE) {

		if (fname == arch && fname != save_fname) {
			efree(arch);
			fname = save_fname;
		}

		if (entry) {
			efree(entry);
		}

		if (error) {
			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
				""%s"", error);
			efree(error);
		} else {
			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
				""Phar creation or opening failed"");
		}

		return;
	}

	if (is_data && phar_data->is_tar && phar_data->is_brandnew && format == PHAR_FORMAT_ZIP) {
		phar_data->is_zip = 1;
		phar_data->is_tar = 0;
	}

	if (fname == arch) {
		efree(arch);
		fname = save_fname;
	}

	if ((is_data && !phar_data->is_data) || (!is_data && phar_data->is_data)) {
		if (is_data) {
			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
				""PharData class can only be used for non-executable tar and zip archives"");
		} else {
			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
				""Phar class can only be used for executable tar and zip archives"");
		}
		efree(entry);
		return;
	}

	is_data = phar_data->is_data;

	if (!phar_data->is_persistent) {
		++(phar_data->refcount);
	}

	phar_obj->arc.archive = phar_data;
	phar_obj->spl.oth_handler = &phar_spl_foreign_handler;

	if (entry) {
		fname_len = spprintf(&fname, 0, ""phar://%s%s"", phar_data->fname, entry);
		efree(entry);
	} else {
		fname_len = spprintf(&fname, 0, ""phar://%s"", phar_data->fname);
	}

	INIT_PZVAL(&arg1);
	ZVAL_STRINGL(&arg1, fname, fname_len, 0);
        INIT_PZVAL(&arg2);
        ZVAL_LONG(&arg2, flags);
 
       zend_call_method_with_2_params(&zobj, Z_OBJCE_P(zobj), 
                &spl_ce_RecursiveDirectoryIterator->constructor, ""__construct"", NULL, &arg1, &arg2);
 
        if (!phar_data->is_persistent) {
		phar_obj->arc.archive->is_data = is_data;
	} else if (!EG(exception)) {
		/* register this guy so we can modify if necessary */
		zend_hash_add(&PHAR_GLOBALS->phar_persist_map, (const char *) phar_obj->arc.archive, sizeof(phar_obj->arc.archive), (void *) &phar_obj, sizeof(phar_archive_object **), NULL);
	}

	phar_obj->spl.info_class = phar_ce_entry;
	efree(fname);
#endif /* HAVE_SPL */
}
/* }}} */

/* {{{ proto array Phar::getSupportedSignatures()
 * Return array of supported signature types
 */
PHP_METHOD(Phar, getSupportedSignatures)
{
        if (zend_parse_parameters_none() == FAILURE) {
                return;
        }
        array_init(return_value);
 
        add_next_index_stringl(return_value, ""MD5"", 3, 1);
	add_next_index_stringl(return_value, ""SHA-1"", 5, 1);
#ifdef PHAR_HASH_OK
	add_next_index_stringl(return_value, ""SHA-256"", 7, 1);
	add_next_index_stringl(return_value, ""SHA-512"", 7, 1);
#endif
#if PHAR_HAVE_OPENSSL
	add_next_index_stringl(return_value, ""OpenSSL"", 7, 1);
#else
	if (zend_hash_exists(&module_registry, ""openssl"", sizeof(""openssl""))) {
		add_next_index_stringl(return_value, ""OpenSSL"", 7, 1);
	}
#endif
}
/* }}} */

/* {{{ proto array Phar::getSupportedCompression()
 * Return array of supported comparession algorithms
 */
PHP_METHOD(Phar, getSupportedCompression)
{
        if (zend_parse_parameters_none() == FAILURE) {
                return;
        }
        array_init(return_value);
        phar_request_initialize(TSRMLS_C);
 
	if (PHAR_G(has_zlib)) {
		add_next_index_stringl(return_value, ""GZ"", 2, 1);
	}

	if (PHAR_G(has_bz2)) {
		add_next_index_stringl(return_value, ""BZIP2"", 5, 1);
	}
}
/* }}} */

/* {{{ proto array Phar::unlinkArchive(string archive)
 * Completely remove a phar archive from memory and disk
 */
PHP_METHOD(Phar, unlinkArchive)
{
	char *fname, *error, *zname, *arch, *entry;
	int fname_len, zname_len, arch_len, entry_len;
	phar_archive_data *phar;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &fname, &fname_len) == FAILURE) {
		RETURN_FALSE;
	}

	if (!fname_len) {
		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""Unknown phar archive \""\"""");
		return;
	}

	if (FAILURE == phar_open_from_filename(fname, fname_len, NULL, 0, REPORT_ERRORS, &phar, &error TSRMLS_CC)) {
		if (error) {
			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""Unknown phar archive \""%s\"": %s"", fname, error);
			efree(error);
		} else {
			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""Unknown phar archive \""%s\"""", fname);
		}
		return;
	}

	zname = (char*)zend_get_executed_filename(TSRMLS_C);
	zname_len = strlen(zname);

	if (zname_len > 7 && !memcmp(zname, ""phar://"", 7) && SUCCESS == phar_split_fname(zname, zname_len, &arch, &arch_len, &entry, &entry_len, 2, 0 TSRMLS_CC)) {
		if (arch_len == fname_len && !memcmp(arch, fname, arch_len)) {
			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar archive \""%s\"" cannot be unlinked from within itself"", fname);
			efree(arch);
			efree(entry);
			return;
		}
		efree(arch);
		efree(entry);
	}

	if (phar->is_persistent) {
		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar archive \""%s\"" is in phar.cache_list, cannot unlinkArchive()"", fname);
		return;
	}

	if (phar->refcount) {
		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar archive \""%s\"" has open file handles or objects.  fclose() all file handles, and unset() all objects prior to calling unlinkArchive()"", fname);
		return;
	}

	fname = estrndup(phar->fname, phar->fname_len);

	/* invalidate phar cache */
	PHAR_G(last_phar) = NULL;
	PHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;

	phar_archive_delref(phar TSRMLS_CC);
	unlink(fname);
	efree(fname);
	RETURN_TRUE;
}
/* }}} */

#if HAVE_SPL

#define PHAR_ARCHIVE_OBJECT() \
	phar_archive_object *phar_obj = (phar_archive_object*)zend_object_store_get_object(getThis() TSRMLS_CC); \
	if (!phar_obj->arc.archive) { \
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \
			""Cannot call method on an uninitialized Phar object""); \
		return; \
	}

/* {{{ proto void Phar::__destruct()
 * if persistent, remove from the cache
 */
PHP_METHOD(Phar, __destruct)
{
	phar_archive_object *phar_obj = (phar_archive_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

	if (phar_obj->arc.archive && phar_obj->arc.archive->is_persistent) {
		zend_hash_del(&PHAR_GLOBALS->phar_persist_map, (const char *) phar_obj->arc.archive, sizeof(phar_obj->arc.archive));
	}
}
/* }}} */

struct _phar_t {
	phar_archive_object *p;
	zend_class_entry *c;
	char *b;
	uint l;
	zval *ret;
	int count;
	php_stream *fp;
};

static int phar_build(zend_object_iterator *iter, void *puser TSRMLS_DC) /* {{{ */
{
	zval **value;
	zend_uchar key_type;
	zend_bool close_fp = 1;
	ulong int_key;
	struct _phar_t *p_obj = (struct _phar_t*) puser;
	uint str_key_len, base_len = p_obj->l, fname_len;
	phar_entry_data *data;
	php_stream *fp;
	size_t contents_len;
	char *fname, *error = NULL, *base = p_obj->b, *opened, *save = NULL, *temp = NULL;
	phar_zstr key;
	char *str_key;
	zend_class_entry *ce = p_obj->c;
	phar_archive_object *phar_obj = p_obj->p;
	char *str = ""[stream]"";

	iter->funcs->get_current_data(iter, &value TSRMLS_CC);

	if (EG(exception)) {
		return ZEND_HASH_APPLY_STOP;
	}

	if (!value) {
		/* failure in get_current_data */
		zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Iterator %v returned no value"", ce->name);
		return ZEND_HASH_APPLY_STOP;
	}

	switch (Z_TYPE_PP(value)) {
#if PHP_VERSION_ID >= 60000
		case IS_UNICODE:
			zval_unicode_to_string(*(value) TSRMLS_CC);
			/* break intentionally omitted */
#endif
		case IS_STRING:
			break;
		case IS_RESOURCE:
			php_stream_from_zval_no_verify(fp, value);

			if (!fp) {
				zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Iterator %v returned an invalid stream handle"", ce->name);
				return ZEND_HASH_APPLY_STOP;
			}

			if (iter->funcs->get_current_key) {
				key_type = iter->funcs->get_current_key(iter, &key, &str_key_len, &int_key TSRMLS_CC);

				if (EG(exception)) {
					return ZEND_HASH_APPLY_STOP;
				}

				if (key_type == HASH_KEY_IS_LONG) {
					zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Iterator %v returned an invalid key (must return a string)"", ce->name);
					return ZEND_HASH_APPLY_STOP;
				}

				if (key_type > 9) { /* IS_UNICODE == 10 */
#if PHP_VERSION_ID < 60000
/* this can never happen, but fixes a compile warning */
					spprintf(&str_key, 0, ""%s"", key);
#else
					spprintf(&str_key, 0, ""%v"", key);
					ezfree(key);
#endif
				} else {
					PHAR_STR(key, str_key);
				}

				save = str_key;

				if (str_key[str_key_len - 1] == '\0') {
					str_key_len--;
				}

			} else {
				zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Iterator %v returned an invalid key (must return a string)"", ce->name);
				return ZEND_HASH_APPLY_STOP;
			}

			close_fp = 0;
			opened = (char *) estrndup(str, sizeof(""[stream]"") - 1);
			goto after_open_fp;
		case IS_OBJECT:
			if (instanceof_function(Z_OBJCE_PP(value), spl_ce_SplFileInfo TSRMLS_CC)) {
				char *test = NULL;
				zval dummy;
				spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(*value TSRMLS_CC);

				if (!base_len) {
					zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Iterator %v returns an SplFileInfo object, so base directory must be specified"", ce->name);
					return ZEND_HASH_APPLY_STOP;
				}

				switch (intern->type) {
					case SPL_FS_DIR:
#if PHP_VERSION_ID >= 60000
						test = spl_filesystem_object_get_path(intern, NULL, NULL TSRMLS_CC).s;
#elif PHP_VERSION_ID >= 50300
						test = spl_filesystem_object_get_path(intern, NULL TSRMLS_CC);
#else
						test = intern->path;
#endif
						fname_len = spprintf(&fname, 0, ""%s%c%s"", test, DEFAULT_SLASH, intern->u.dir.entry.d_name);
						php_stat(fname, fname_len, FS_IS_DIR, &dummy TSRMLS_CC);

						if (Z_BVAL(dummy)) {
							/* ignore directories */
							efree(fname);
							return ZEND_HASH_APPLY_KEEP;
						}

						test = expand_filepath(fname, NULL TSRMLS_CC);
						efree(fname);

						if (test) {
							fname = test;
							fname_len = strlen(fname);
						} else {
							zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Could not resolve file path"");
							return ZEND_HASH_APPLY_STOP;
						}

						save = fname;
						goto phar_spl_fileinfo;
					case SPL_FS_INFO:
					case SPL_FS_FILE:
#if PHP_VERSION_ID >= 60000
						if (intern->file_name_type == IS_UNICODE) {
							zval zv;

							INIT_ZVAL(zv);
							Z_UNIVAL(zv) = intern->file_name;
							Z_UNILEN(zv) = intern->file_name_len;
							Z_TYPE(zv) = IS_UNICODE;

							zval_copy_ctor(&zv);
							zval_unicode_to_string(&zv TSRMLS_CC);
							fname = expand_filepath(Z_STRVAL(zv), NULL TSRMLS_CC);
							ezfree(Z_UNIVAL(zv));
						} else {
							fname = expand_filepath(intern->file_name.s, NULL TSRMLS_CC);
						}
#else
						fname = expand_filepath(intern->file_name, NULL TSRMLS_CC);
#endif
						if (!fname) {
							zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Could not resolve file path"");
							return ZEND_HASH_APPLY_STOP;
						}

						fname_len = strlen(fname);
						save = fname;
						goto phar_spl_fileinfo;
				}
			}
			/* fall-through */
		default:
			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Iterator %v returned an invalid value (must return a string)"", ce->name);
			return ZEND_HASH_APPLY_STOP;
	}

	fname = Z_STRVAL_PP(value);
	fname_len = Z_STRLEN_PP(value);

phar_spl_fileinfo:
	if (base_len) {
		temp = expand_filepath(base, NULL TSRMLS_CC);
		if (!temp) {
			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Could not resolve file path"");
			if (save) {
				efree(save);
                        }
                        return ZEND_HASH_APPLY_STOP;
                }
                base = temp;
                base_len = strlen(base);
 
		if (strstr(fname, base)) {
			str_key_len = fname_len - base_len;

			if (str_key_len <= 0) {
				if (save) {
					efree(save);
					efree(temp);
				}
				return ZEND_HASH_APPLY_KEEP;
			}

			str_key = fname + base_len;

			if (*str_key == '/' || *str_key == '\\') {
				str_key++;
				str_key_len--;
			}

		} else {
			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Iterator %v returned a path \""%s\"" that is not in the base directory \""%s\"""", ce->name, fname, base);

			if (save) {
				efree(save);
				efree(temp);
			}

			return ZEND_HASH_APPLY_STOP;
		}
	} else {
		if (iter->funcs->get_current_key) {
			key_type = iter->funcs->get_current_key(iter, &key, &str_key_len, &int_key TSRMLS_CC);

			if (EG(exception)) {
				return ZEND_HASH_APPLY_STOP;
			}

			if (key_type == HASH_KEY_IS_LONG) {
				zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Iterator %v returned an invalid key (must return a string)"", ce->name);
				return ZEND_HASH_APPLY_STOP;
			}

			if (key_type > 9) { /* IS_UNICODE == 10 */
#if PHP_VERSION_ID < 60000
/* this can never happen, but fixes a compile warning */
				spprintf(&str_key, 0, ""%s"", key);
#else
				spprintf(&str_key, 0, ""%v"", key);
				ezfree(key);
#endif
			} else {
				PHAR_STR(key, str_key);
			}

			save = str_key;

			if (str_key[str_key_len - 1] == '\0') str_key_len--;
		} else {
			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Iterator %v returned an invalid key (must return a string)"", ce->name);
			return ZEND_HASH_APPLY_STOP;
		}
	}
#if PHP_API_VERSION < 20100412
	if (PG(safe_mode) && (!php_checkuid(fname, NULL, CHECKUID_ALLOW_ONLY_FILE))) {
		zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Iterator %v returned a path \""%s\"" that safe mode prevents opening"", ce->name, fname);

		if (save) {
			efree(save);
		}

		if (temp) {
			efree(temp);
		}

		return ZEND_HASH_APPLY_STOP;
	}
#endif

	if (php_check_open_basedir(fname TSRMLS_CC)) {
		zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Iterator %v returned a path \""%s\"" that open_basedir prevents opening"", ce->name, fname);

		if (save) {
			efree(save);
		}

		if (temp) {
			efree(temp);
		}

		return ZEND_HASH_APPLY_STOP;
	}

	/* try to open source file, then create internal phar file and copy contents */
	fp = php_stream_open_wrapper(fname, ""rb"", STREAM_MUST_SEEK|0, &opened);

	if (!fp) {
		zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Iterator %v returned a file that could not be opened \""%s\"""", ce->name, fname);

		if (save) {
			efree(save);
		}

		if (temp) {
			efree(temp);
		}

		return ZEND_HASH_APPLY_STOP;
	}
after_open_fp:
	if (str_key_len >= sizeof("".phar"")-1 && !memcmp(str_key, "".phar"", sizeof("".phar"")-1)) {
		/* silently skip any files that would be added to the magic .phar directory */
		if (save) {
			efree(save);
		}

		if (temp) {
			efree(temp);
		}

		if (opened) {
			efree(opened);
		}

		if (close_fp) {
			php_stream_close(fp);
		}

		return ZEND_HASH_APPLY_KEEP;
	}

	if (!(data = phar_get_or_create_entry_data(phar_obj->arc.archive->fname, phar_obj->arc.archive->fname_len, str_key, str_key_len, ""w+b"", 0, &error, 1 TSRMLS_CC))) {
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Entry %s cannot be created: %s"", str_key, error);
		efree(error);

		if (save) {
			efree(save);
		}

		if (opened) {
			efree(opened);
		}

		if (temp) {
			efree(temp);
		}

		if (close_fp) {
			php_stream_close(fp);
		}

		return ZEND_HASH_APPLY_STOP;

	} else {
		if (error) {
			efree(error);
		}
		/* convert to PHAR_UFP */
		if (data->internal_file->fp_type == PHAR_MOD) {
			php_stream_close(data->internal_file->fp);
		}

		data->internal_file->fp = NULL;
		data->internal_file->fp_type = PHAR_UFP;
		data->internal_file->offset_abs = data->internal_file->offset = php_stream_tell(p_obj->fp);
		data->fp = NULL;
		phar_stream_copy_to_stream(fp, p_obj->fp, PHP_STREAM_COPY_ALL, &contents_len);
		data->internal_file->uncompressed_filesize = data->internal_file->compressed_filesize =
			php_stream_tell(p_obj->fp) - data->internal_file->offset;
	}

	if (close_fp) {
		php_stream_close(fp);
	}

	add_assoc_string(p_obj->ret, str_key, opened, 0);

	if (save) {
		efree(save);
	}

	if (temp) {
		efree(temp);
	}

	data->internal_file->compressed_filesize = data->internal_file->uncompressed_filesize = contents_len;
	phar_entry_delref(data TSRMLS_CC);

	return ZEND_HASH_APPLY_KEEP;
}
/* }}} */

 /* {{{ proto array Phar::buildFromDirectory(string base_dir[, string regex])
  * Construct a phar archive from an existing directory, recursively.
  * Optional second parameter is a regular expression for filtering directory contents.
 * 
  * Return value is an array mapping phar index to actual files added.
  */
 PHP_METHOD(Phar, buildFromDirectory)
{
	char *dir, *error, *regex = NULL;
	int dir_len, regex_len = 0;
	zend_bool apply_reg = 0;
	zval arg, arg2, *iter, *iteriter, *regexiter = NULL;
	struct _phar_t pass;

	PHAR_ARCHIVE_OBJECT();

	if (PHAR_G(readonly) && !phar_obj->arc.archive->is_data) {
		zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
			""Cannot write to archive - write operations restricted by INI setting"");
		return;
	}

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|s"", &dir, &dir_len, &regex, &regex_len) == FAILURE) {
		RETURN_FALSE;
	}

	MAKE_STD_ZVAL(iter);

	if (SUCCESS != object_init_ex(iter, spl_ce_RecursiveDirectoryIterator)) {
		zval_ptr_dtor(&iter);
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Unable to instantiate directory iterator for %s"", phar_obj->arc.archive->fname);
		RETURN_FALSE;
	}

	INIT_PZVAL(&arg);
	ZVAL_STRINGL(&arg, dir, dir_len, 0);
	INIT_PZVAL(&arg2);
#if PHP_VERSION_ID < 50300
	ZVAL_LONG(&arg2, 0);
#else
        ZVAL_LONG(&arg2, SPL_FILE_DIR_SKIPDOTS|SPL_FILE_DIR_UNIXPATHS);
 #endif
 
       zend_call_method_with_2_params(&iter, spl_ce_RecursiveDirectoryIterator, 
                        &spl_ce_RecursiveDirectoryIterator->constructor, ""__construct"", NULL, &arg, &arg2);
 
        if (EG(exception)) {
		zval_ptr_dtor(&iter);
		RETURN_FALSE;
	}

	MAKE_STD_ZVAL(iteriter);

	if (SUCCESS != object_init_ex(iteriter, spl_ce_RecursiveIteratorIterator)) {
		zval_ptr_dtor(&iter);
		zval_ptr_dtor(&iteriter);
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Unable to instantiate directory iterator for %s"", phar_obj->arc.archive->fname);
                RETURN_FALSE;
        }
 
       zend_call_method_with_1_params(&iteriter, spl_ce_RecursiveIteratorIterator, 
                        &spl_ce_RecursiveIteratorIterator->constructor, ""__construct"", NULL, iter);
 
        if (EG(exception)) {
		zval_ptr_dtor(&iter);
		zval_ptr_dtor(&iteriter);
		RETURN_FALSE;
	}

	zval_ptr_dtor(&iter);

	if (regex_len > 0) {
		apply_reg = 1;
		MAKE_STD_ZVAL(regexiter);

		if (SUCCESS != object_init_ex(regexiter, spl_ce_RegexIterator)) {
			zval_ptr_dtor(&iteriter);
			zval_dtor(regexiter);
			zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Unable to instantiate regex iterator for %s"", phar_obj->arc.archive->fname);
			RETURN_FALSE;
		}

                INIT_PZVAL(&arg2);
                ZVAL_STRINGL(&arg2, regex, regex_len, 0);
 
               zend_call_method_with_2_params(&regexiter, spl_ce_RegexIterator, 
                        &spl_ce_RegexIterator->constructor, ""__construct"", NULL, iteriter, &arg2);
        }
 
	array_init(return_value);

	pass.c = apply_reg ? Z_OBJCE_P(regexiter) : Z_OBJCE_P(iteriter);
	pass.p = phar_obj;
	pass.b = dir;
	pass.l = dir_len;
	pass.count = 0;
	pass.ret = return_value;
	pass.fp = php_stream_fopen_tmpfile();
	if (pass.fp == NULL) {
		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar \""%s\"" unable to create temporary file"", phar_obj->arc.archive->fname);
		return;
	}

	if (phar_obj->arc.archive->is_persistent && FAILURE == phar_copy_on_write(&(phar_obj->arc.archive) TSRMLS_CC)) {
		zval_ptr_dtor(&iteriter);
		if (apply_reg) {
			zval_ptr_dtor(&regexiter);
		}
		php_stream_close(pass.fp);
		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar \""%s\"" is persistent, unable to copy on write"", phar_obj->arc.archive->fname);
		return;
	}

	if (SUCCESS == spl_iterator_apply((apply_reg ? regexiter : iteriter), (spl_iterator_apply_func_t) phar_build, (void *) &pass TSRMLS_CC)) {
		zval_ptr_dtor(&iteriter);

		if (apply_reg) {
			zval_ptr_dtor(&regexiter);
		}

		phar_obj->arc.archive->ufp = pass.fp;
		phar_flush(phar_obj->arc.archive, 0, 0, 0, &error TSRMLS_CC);

		if (error) {
			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""%s"", error);
			efree(error);
		}

	} else {
		zval_ptr_dtor(&iteriter);
		if (apply_reg) {
			zval_ptr_dtor(&regexiter);
		}
		php_stream_close(pass.fp);
	}
}
/* }}} */

/* {{{ proto array Phar::buildFromIterator(Iterator iter[, string base_directory])
 * Construct a phar archive from an iterator.  The iterator must return a series of strings
 * that are full paths to files that should be added to the phar.  The iterator key should
 * be the path that the file will have within the phar archive.
 *
 * If base directory is specified, then the key will be ignored, and instead the portion of
 * the current value minus the base directory will be used
 *
 * Returned is an array mapping phar index to actual file added
 */
PHP_METHOD(Phar, buildFromIterator)
{
	zval *obj;
	char *error;
	uint base_len = 0;
	char *base = NULL;
	struct _phar_t pass;

	PHAR_ARCHIVE_OBJECT();

	if (PHAR_G(readonly) && !phar_obj->arc.archive->is_data) {
		zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
			""Cannot write out phar archive, phar is read-only"");
		return;
	}

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""O|s"", &obj, zend_ce_traversable, &base, &base_len) == FAILURE) {
		RETURN_FALSE;
	}

	if (phar_obj->arc.archive->is_persistent && FAILURE == phar_copy_on_write(&(phar_obj->arc.archive) TSRMLS_CC)) {
		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar \""%s\"" is persistent, unable to copy on write"", phar_obj->arc.archive->fname);
		return;
	}

	array_init(return_value);

	pass.c = Z_OBJCE_P(obj);
	pass.p = phar_obj;
	pass.b = base;
	pass.l = base_len;
	pass.ret = return_value;
	pass.count = 0;
	pass.fp = php_stream_fopen_tmpfile();
	if (pass.fp == NULL) {
		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""phar \""%s\"": unable to create temporary file"", phar_obj->arc.archive->fname);
		return;
	}

	if (SUCCESS == spl_iterator_apply(obj, (spl_iterator_apply_func_t) phar_build, (void *) &pass TSRMLS_CC)) {
		phar_obj->arc.archive->ufp = pass.fp;
		phar_flush(phar_obj->arc.archive, 0, 0, 0, &error TSRMLS_CC);
		if (error) {
			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""%s"", error);
			efree(error);
		}
	} else {
		php_stream_close(pass.fp);
	}
}
/* }}} */

/* {{{ proto int Phar::count()
 * Returns the number of entries in the Phar archive
 */
 PHP_METHOD(Phar, count)
 {
        PHAR_ARCHIVE_OBJECT();
        if (zend_parse_parameters_none() == FAILURE) {
                return;
        }

	RETURN_LONG(zend_hash_num_elements(&phar_obj->arc.archive->manifest));
}
/* }}} */

/* {{{ proto bool Phar::isFileFormat(int format)
 * Returns true if the phar archive is based on the tar/zip/phar file format depending
 * on whether Phar::TAR, Phar::ZIP or Phar::PHAR was passed in
 */
PHP_METHOD(Phar, isFileFormat)
{
	long type;
	PHAR_ARCHIVE_OBJECT();

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &type) == FAILURE) {
		RETURN_FALSE;
	}

	switch (type) {
		case PHAR_FORMAT_TAR:
			RETURN_BOOL(phar_obj->arc.archive->is_tar);
		case PHAR_FORMAT_ZIP:
			RETURN_BOOL(phar_obj->arc.archive->is_zip);
		case PHAR_FORMAT_PHAR:
			RETURN_BOOL(!phar_obj->arc.archive->is_tar && !phar_obj->arc.archive->is_zip);
		default:
			zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""Unknown file format specified"");
	}
}
/* }}} */

static int phar_copy_file_contents(phar_entry_info *entry, php_stream *fp TSRMLS_DC) /* {{{ */
{
	char *error;
	off_t offset;
	phar_entry_info *link;

	if (FAILURE == phar_open_entry_fp(entry, &error, 1 TSRMLS_CC)) {
		if (error) {
			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
				""Cannot convert phar archive \""%s\"", unable to open entry \""%s\"" contents: %s"", entry->phar->fname, entry->filename, error);
			efree(error);
		} else {
			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
				""Cannot convert phar archive \""%s\"", unable to open entry \""%s\"" contents"", entry->phar->fname, entry->filename);
		}
		return FAILURE;
	}

	/* copy old contents in entirety */
	phar_seek_efp(entry, 0, SEEK_SET, 0, 1 TSRMLS_CC);
	offset = php_stream_tell(fp);
	link = phar_get_link_source(entry TSRMLS_CC);

	if (!link) {
		link = entry;
	}

	if (SUCCESS != phar_stream_copy_to_stream(phar_get_efp(link, 0 TSRMLS_CC), fp, link->uncompressed_filesize, NULL)) {
		zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
			""Cannot convert phar archive \""%s\"", unable to copy entry \""%s\"" contents"", entry->phar->fname, entry->filename);
		return FAILURE;
	}

	if (entry->fp_type == PHAR_MOD) {
		/* save for potential restore on error */
		entry->cfp = entry->fp;
		entry->fp = NULL;
	}

	/* set new location of file contents */
	entry->fp_type = PHAR_FP;
	entry->offset = offset;
	return SUCCESS;
}
/* }}} */

static zval *phar_rename_archive(phar_archive_data *phar, char *ext, zend_bool compress TSRMLS_DC) /* {{{ */
{
	const char *oldname = NULL;
	char *oldpath = NULL;
	char *basename = NULL, *basepath = NULL;
	char *newname = NULL, *newpath = NULL;
	zval *ret, arg1;
	zend_class_entry *ce;
	char *error;
	const char *pcr_error;
	int ext_len = ext ? strlen(ext) : 0;
	int oldname_len;
	phar_archive_data **pphar = NULL;
	php_stream_statbuf ssb;

	if (!ext) {
		if (phar->is_zip) {

			if (phar->is_data) {
				ext = ""zip"";
			} else {
				ext = ""phar.zip"";
			}

		} else if (phar->is_tar) {

			switch (phar->flags) {
				case PHAR_FILE_COMPRESSED_GZ:
					if (phar->is_data) {
						ext = ""tar.gz"";
					} else {
						ext = ""phar.tar.gz"";
					}
					break;
				case PHAR_FILE_COMPRESSED_BZ2:
					if (phar->is_data) {
						ext = ""tar.bz2"";
					} else {
						ext = ""phar.tar.bz2"";
					}
					break;
				default:
					if (phar->is_data) {
						ext = ""tar"";
					} else {
						ext = ""phar.tar"";
					}
			}
		} else {

			switch (phar->flags) {
				case PHAR_FILE_COMPRESSED_GZ:
					ext = ""phar.gz"";
					break;
				case PHAR_FILE_COMPRESSED_BZ2:
					ext = ""phar.bz2"";
					break;
				default:
					ext = ""phar"";
			}
		}
	} else if (phar_path_check(&ext, &ext_len, &pcr_error) > pcr_is_ok) {

		if (phar->is_data) {
			zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""data phar converted from \""%s\"" has invalid extension %s"", phar->fname, ext);
		} else {
			zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""phar converted from \""%s\"" has invalid extension %s"", phar->fname, ext);
		}
		return NULL;
	}

	if (ext[0] == '.') {
		++ext;
	}

	oldpath = estrndup(phar->fname, phar->fname_len);
	oldname = zend_memrchr(phar->fname, '/', phar->fname_len);
	++oldname;
	oldname_len = strlen(oldname);

	basename = estrndup(oldname, oldname_len);
        spprintf(&newname, 0, ""%s.%s"", strtok(basename, "".""), ext);
        efree(basename);
 
 
        basepath = estrndup(oldpath, (strlen(oldpath) - oldname_len));
        phar->fname_len = spprintf(&newpath, 0, ""%s%s"", basepath, newname);
	phar->fname = newpath;
	phar->ext = newpath + phar->fname_len - strlen(ext) - 1;
	efree(basepath);
	efree(newname);

	if (PHAR_G(manifest_cached) && SUCCESS == zend_hash_find(&cached_phars, newpath, phar->fname_len, (void **) &pphar)) {
		efree(oldpath);
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Unable to add newly converted phar \""%s\"" to the list of phars, new phar name is in phar.cache_list"", phar->fname);
		return NULL;
	}

	if (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_fname_map), newpath, phar->fname_len, (void **) &pphar)) {
		if ((*pphar)->fname_len == phar->fname_len && !memcmp((*pphar)->fname, phar->fname, phar->fname_len)) {
			if (!zend_hash_num_elements(&phar->manifest)) {
				(*pphar)->is_tar = phar->is_tar;
				(*pphar)->is_zip = phar->is_zip;
				(*pphar)->is_data = phar->is_data;
				(*pphar)->flags = phar->flags;
				(*pphar)->fp = phar->fp;
				phar->fp = NULL;
				phar_destroy_phar_data(phar TSRMLS_CC);
				phar = *pphar;
				phar->refcount++;
				newpath = oldpath;
				goto its_ok;
			}
		}

		efree(oldpath);
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Unable to add newly converted phar \""%s\"" to the list of phars, a phar with that name already exists"", phar->fname);
		return NULL;
	}
its_ok:
	if (SUCCESS == php_stream_stat_path(newpath, &ssb)) {
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""phar \""%s\"" exists and must be unlinked prior to conversion"", newpath);
		efree(oldpath);
		return NULL;
	}
	if (!phar->is_data) {
		if (SUCCESS != phar_detect_phar_fname_ext(newpath, phar->fname_len, (const char **) &(phar->ext), &(phar->ext_len), 1, 1, 1 TSRMLS_CC)) {
			efree(oldpath);
			zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""phar \""%s\"" has invalid extension %s"", phar->fname, ext);
			return NULL;
		}

		if (phar->alias) {
			if (phar->is_temporary_alias) {
				phar->alias = NULL;
				phar->alias_len = 0;
			} else {
				phar->alias = estrndup(newpath, strlen(newpath));
				phar->alias_len = strlen(newpath);
				phar->is_temporary_alias = 1;
				zend_hash_update(&(PHAR_GLOBALS->phar_alias_map), newpath, phar->fname_len, (void*)&phar, sizeof(phar_archive_data*), NULL);
			}
		}

	} else {

		if (SUCCESS != phar_detect_phar_fname_ext(newpath, phar->fname_len, (const char **) &(phar->ext), &(phar->ext_len), 0, 1, 1 TSRMLS_CC)) {
			efree(oldpath);
			zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""data phar \""%s\"" has invalid extension %s"", phar->fname, ext);
			return NULL;
		}

		phar->alias = NULL;
		phar->alias_len = 0;
	}

	if ((!pphar || phar == *pphar) && SUCCESS != zend_hash_update(&(PHAR_GLOBALS->phar_fname_map), newpath, phar->fname_len, (void*)&phar, sizeof(phar_archive_data*), NULL)) {
		efree(oldpath);
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Unable to add newly converted phar \""%s\"" to the list of phars"", phar->fname);
		return NULL;
	}

	phar_flush(phar, 0, 0, 1, &error TSRMLS_CC);

	if (error) {
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""%s"", error);
		efree(error);
		efree(oldpath);
		return NULL;
	}

	efree(oldpath);

	if (phar->is_data) {
		ce = phar_ce_data;
	} else {
		ce = phar_ce_archive;
	}

	MAKE_STD_ZVAL(ret);

	if (SUCCESS != object_init_ex(ret, ce)) {
		zval_dtor(ret);
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Unable to instantiate phar object when converting archive \""%s\"""", phar->fname);
		return NULL;
	}

	INIT_PZVAL(&arg1);
	ZVAL_STRINGL(&arg1, phar->fname, phar->fname_len, 0);

	zend_call_method_with_1_params(&ret, ce, &ce->constructor, ""__construct"", NULL, &arg1);
	return ret;
}
/* }}} */

static zval *phar_convert_to_other(phar_archive_data *source, int convert, char *ext, php_uint32 flags TSRMLS_DC) /* {{{ */
{
	phar_archive_data *phar;
	phar_entry_info *entry, newentry;
	zval *ret;

	/* invalidate phar cache */
	PHAR_G(last_phar) = NULL;
	PHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;

	phar = (phar_archive_data *) ecalloc(1, sizeof(phar_archive_data));
	/* set whole-archive compression and type from parameter */
	phar->flags = flags;
	phar->is_data = source->is_data;

	switch (convert) {
		case PHAR_FORMAT_TAR:
			phar->is_tar = 1;
			break;
		case PHAR_FORMAT_ZIP:
			phar->is_zip = 1;
			break;
		default:
			phar->is_data = 0;
			break;
	}

	zend_hash_init(&(phar->manifest), sizeof(phar_entry_info),
		zend_get_hash_value, destroy_phar_manifest_entry, 0);
	zend_hash_init(&phar->mounted_dirs, sizeof(char *),
		zend_get_hash_value, NULL, 0);
	zend_hash_init(&phar->virtual_dirs, sizeof(char *),
		zend_get_hash_value, NULL, 0);

	phar->fp = php_stream_fopen_tmpfile();
	if (phar->fp == NULL) {
		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""unable to create temporary file"");
		return NULL;
	}
	phar->fname = source->fname;
	phar->fname_len = source->fname_len;
	phar->is_temporary_alias = source->is_temporary_alias;
	phar->alias = source->alias;

	if (source->metadata) {
		zval *t;

		t = source->metadata;
		ALLOC_ZVAL(phar->metadata);
		*phar->metadata = *t;
		zval_copy_ctor(phar->metadata);
#if PHP_VERSION_ID < 50300
		phar->metadata->refcount = 1;
#else
		Z_SET_REFCOUNT_P(phar->metadata, 1);
#endif

		phar->metadata_len = 0;
	}

	/* first copy each file's uncompressed contents to a temporary file and set per-file flags */
	for (zend_hash_internal_pointer_reset(&source->manifest); SUCCESS == zend_hash_has_more_elements(&source->manifest); zend_hash_move_forward(&source->manifest)) {

		if (FAILURE == zend_hash_get_current_data(&source->manifest, (void **) &entry)) {
			zend_hash_destroy(&(phar->manifest));
			php_stream_close(phar->fp);
			efree(phar);
			zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,
				""Cannot convert phar archive \""%s\"""", source->fname);
			return NULL;
		}

		newentry = *entry;

		if (newentry.link) {
			newentry.link = estrdup(newentry.link);
			goto no_copy;
		}

		if (newentry.tmp) {
			newentry.tmp = estrdup(newentry.tmp);
			goto no_copy;
		}

		newentry.metadata_str.c = 0;

		if (FAILURE == phar_copy_file_contents(&newentry, phar->fp TSRMLS_CC)) {
			zend_hash_destroy(&(phar->manifest));
			php_stream_close(phar->fp);
			efree(phar);
			/* exception already thrown */
			return NULL;
		}
no_copy:
		newentry.filename = estrndup(newentry.filename, newentry.filename_len);

		if (newentry.metadata) {
			zval *t;

			t = newentry.metadata;
			ALLOC_ZVAL(newentry.metadata);
			*newentry.metadata = *t;
			zval_copy_ctor(newentry.metadata);
#if PHP_VERSION_ID < 50300
			newentry.metadata->refcount = 1;
#else
			Z_SET_REFCOUNT_P(newentry.metadata, 1);
#endif

			newentry.metadata_str.c = NULL;
			newentry.metadata_str.len = 0;
		}

		newentry.is_zip = phar->is_zip;
		newentry.is_tar = phar->is_tar;

		if (newentry.is_tar) {
			newentry.tar_type = (entry->is_dir ? TAR_DIR : TAR_FILE);
		}

		newentry.is_modified = 1;
		newentry.phar = phar;
		newentry.old_flags = newentry.flags & ~PHAR_ENT_COMPRESSION_MASK; /* remove compression from old_flags */
		phar_set_inode(&newentry TSRMLS_CC);
		zend_hash_add(&(phar->manifest), newentry.filename, newentry.filename_len, (void*)&newentry, sizeof(phar_entry_info), NULL);
		phar_add_virtual_dirs(phar, newentry.filename, newentry.filename_len TSRMLS_CC);
	}

	if ((ret = phar_rename_archive(phar, ext, 0 TSRMLS_CC))) {
		return ret;
	} else {
                zend_hash_destroy(&(phar->manifest));
                zend_hash_destroy(&(phar->mounted_dirs));
                zend_hash_destroy(&(phar->virtual_dirs));
               php_stream_close(phar->fp);
                efree(phar->fname);
                efree(phar);
                return NULL;
/* }}} */
",agree
CVE-2018-6791,"void DelayedExecutor::delayedExecute(const QString &udi)
{
    Solid::Device device(udi);
 
     QString exec = m_service.exec();
     MacroExpander mx(device);
    mx.expandMacros(exec);
 
     KRun::runCommand(exec, QString(), m_service.icon(), 0);
     deleteLater();
}
",agree
CVE-2016-5351,"static INT AirPDcapScanForKeys(
    PAIRPDCAP_CONTEXT ctx,
    const guint8 *data,
    const guint mac_header_len,
    const guint tot_len,
    AIRPDCAP_SEC_ASSOCIATION_ID id
)
{
    const UCHAR *addr;
    guint bodyLength;
    PAIRPDCAP_SEC_ASSOCIATION sta_sa;
    PAIRPDCAP_SEC_ASSOCIATION sa;
    guint offset = 0;
    const guint8 dot1x_header[] = {
        0xAA,             /* DSAP=SNAP */
        0xAA,             /* SSAP=SNAP */
        0x03,             /* Control field=Unnumbered frame */
        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */
        0x88, 0x8E        /* Type: 802.1X authentication */
    };
    const guint8 bt_dot1x_header[] = {
        0xAA,             /* DSAP=SNAP */
        0xAA,             /* SSAP=SNAP */
        0x03,             /* Control field=Unnumbered frame */
        0x00, 0x19, 0x58, /* Org. code=Bluetooth SIG */
        0x00, 0x03        /* Type: Bluetooth Security */
    };
    const guint8 tdls_header[] = {
        0xAA,             /* DSAP=SNAP */
        0xAA,             /* SSAP=SNAP */
        0x03,             /* Control field=Unnumbered frame */
        0x00, 0x00, 0x00, /* Org. code=encaps. Ethernet */
        0x89, 0x0D,       /* Type: 802.11 - Fast Roaming Remote Request */
        0x02,             /* Payload Type: TDLS */
        0X0C              /* Action Category: TDLS */
    };

    const EAPOL_RSN_KEY *pEAPKey;
#ifdef _DEBUG
#define MSGBUF_LEN 255
    CHAR msgbuf[MSGBUF_LEN];
#endif
    AIRPDCAP_DEBUG_TRACE_START(""AirPDcapScanForKeys"");

    /* cache offset in the packet data */
    offset = mac_header_len;

    /* check if the packet has an LLC header and the packet is 802.1X authentication (IEEE 802.1X-2004, pg. 24) */
    if (memcmp(data+offset, dot1x_header, 8) == 0 || memcmp(data+offset, bt_dot1x_header, 8) == 0) {

        AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Authentication: EAPOL packet"", AIRPDCAP_DEBUG_LEVEL_3);

        /* skip LLC header */
        offset+=8;

        /* check if the packet is a EAPOL-Key (0x03) (IEEE 802.1X-2004, pg. 25) */
        if (data[offset+1]!=3) {
            AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Not EAPOL-Key"", AIRPDCAP_DEBUG_LEVEL_3);
            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
        }
 
         /* get and check the body length (IEEE 802.1X-2004, pg. 25) */
         bodyLength=pntoh16(data+offset+2);
        if ((tot_len-offset-4) < bodyLength) { /* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 */
             AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""EAPOL body too short"", AIRPDCAP_DEBUG_LEVEL_3);
             return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
         }

        /* skip EAPOL MPDU and go to the first byte of the body */
        offset+=4;

        pEAPKey = (const EAPOL_RSN_KEY *) (data+offset);

        /* check if the key descriptor type is valid (IEEE 802.1X-2004, pg. 27) */
        if (/*pEAPKey->type!=0x1 &&*/ /* RC4 Key Descriptor Type (deprecated) */
            pEAPKey->type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR &&             /* IEEE 802.11 Key Descriptor Type  (WPA2) */
            pEAPKey->type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR)           /* 254 = RSN_KEY_DESCRIPTOR - WPA,              */
        {
            AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Not valid key descriptor type"", AIRPDCAP_DEBUG_LEVEL_3);
            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
        }

        /* start with descriptor body */
        offset+=1;

        /* search for a cached Security Association for current BSSID and AP */
        sa = AirPDcapGetSaPtr(ctx, &id);
        if (sa == NULL){
            AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""No SA for BSSID found"", AIRPDCAP_DEBUG_LEVEL_3);
            return AIRPDCAP_RET_REQ_DATA;
        }

        /* It could be a Pairwise Key exchange, check */
        if (AirPDcapRsna4WHandshake(ctx, data, sa, offset, tot_len) == AIRPDCAP_RET_SUCCESS_HANDSHAKE)
            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;

        if (mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len) {
            AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Message too short for Group Key"", AIRPDCAP_DEBUG_LEVEL_3);
            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
        }

        /* Verify the bitfields: Key = 0(groupwise) Mic = 1 Ack = 1 Secure = 1 */
        if (AIRPDCAP_EAP_KEY(data[offset+1])!=0 ||
            AIRPDCAP_EAP_ACK(data[offset+1])!=1 ||
            AIRPDCAP_EAP_MIC(data[offset]) != 1 ||
            AIRPDCAP_EAP_SEC(data[offset]) != 1){

            AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Key bitfields not correct for Group Key"", AIRPDCAP_DEBUG_LEVEL_3);
            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
        }

        /* force STA address to be the broadcast MAC so we create an SA for the groupkey */
        memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);

        /* get the Security Association structure for the broadcast MAC and AP */
        sa = AirPDcapGetSaPtr(ctx, &id);
        if (sa == NULL){
            return AIRPDCAP_RET_REQ_DATA;
        }

        /* Get the SA for the STA, since we need its pairwise key to decrpyt the group key */

        /* get STA address */
        if ( (addr=AirPDcapGetStaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data))) != NULL) {
            memcpy(id.sta, addr, AIRPDCAP_MAC_LEN);
#ifdef _DEBUG
            g_snprintf(msgbuf, MSGBUF_LEN, ""ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\t"", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);
#endif
            AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);
        } else {
            AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""SA not found"", AIRPDCAP_DEBUG_LEVEL_5);
            return AIRPDCAP_RET_REQ_DATA;
        }

        sta_sa = AirPDcapGetSaPtr(ctx, &id);
        if (sta_sa == NULL){
            return AIRPDCAP_RET_REQ_DATA;
        }

        /* Try to extract the group key and install it in the SA */
        return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sta_sa->wpa.ptk+16, sa, tot_len-offset+1));

    } else if (memcmp(data+offset, tdls_header, 10) == 0) {
        const guint8 *initiator, *responder;
        guint8 action;
        guint status, offset_rsne = 0, offset_fte = 0, offset_link = 0, offset_timeout = 0;
        AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Authentication: TDLS Action Frame"", AIRPDCAP_DEBUG_LEVEL_3);

        /* skip LLC header */
        offset+=10;

        /* check if the packet is a TDLS response or confirm */
        action = data[offset];
        if (action!=1 && action!=2) {
            AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Not Response nor confirm"", AIRPDCAP_DEBUG_LEVEL_3);
            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
        }

        /* check status */
        offset++;
        status=pntoh16(data+offset);
        if (status!=0) {
            AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""TDLS setup not successfull"", AIRPDCAP_DEBUG_LEVEL_3);
            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
        }

        /* skip Token + capabilities */
        offset+=5;

        /* search for RSN, Fast BSS Transition, Link Identifier and Timeout Interval IEs */

        while(offset < (tot_len - 2)) {
            if (data[offset] == 48) {
                offset_rsne = offset;
            } else if (data[offset] == 55) {
                offset_fte = offset;
            } else if (data[offset] == 56) {
                offset_timeout = offset;
            } else if (data[offset] == 101) {
                offset_link = offset;
            }

            if (tot_len < offset + data[offset + 1] + 2) {
                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
            }
            offset += data[offset + 1] + 2;
        }

        if (offset_rsne == 0 || offset_fte == 0 ||
            offset_timeout == 0 || offset_link == 0)
        {
            AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Cannot Find all necessary IEs"", AIRPDCAP_DEBUG_LEVEL_3);
            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
        }

        AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Found RSNE/Fast BSS/Timeout Interval/Link IEs"", AIRPDCAP_DEBUG_LEVEL_3);

        /* Will create a Security Association between 2 STA. Need to get both MAC address */
        initiator = &data[offset_link + 8];
        responder = &data[offset_link + 14];

        if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {
            memcpy(id.sta, initiator, AIRPDCAP_MAC_LEN);
            memcpy(id.bssid, responder, AIRPDCAP_MAC_LEN);
        } else {
            memcpy(id.sta, responder, AIRPDCAP_MAC_LEN);
            memcpy(id.bssid, initiator, AIRPDCAP_MAC_LEN);
        }

        sa = AirPDcapGetSaPtr(ctx, &id);
        if (sa == NULL){
            return AIRPDCAP_RET_REQ_DATA;
        }

        if (sa->validKey) {
            if (memcmp(sa->wpa.nonce, data + offset_fte + 52, AIRPDCAP_WPA_NONCE_LEN) == 0) {
                /* Already have valid key for this SA, no need to redo key derivation */
                return AIRPDCAP_RET_SUCCESS_HANDSHAKE;
            } else {
                /* We are opening a new session with the same two STA, save previous sa  */
                AIRPDCAP_SEC_ASSOCIATION *tmp_sa = g_new(AIRPDCAP_SEC_ASSOCIATION, 1);
                memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));
                sa->next=tmp_sa;
                sa->validKey = FALSE;
            }
        }

        if (AirPDcapTDLSDeriveKey(sa, data, offset_rsne, offset_fte, offset_timeout, offset_link, action)
            == AIRPDCAP_RET_SUCCESS) {
            AIRPDCAP_DEBUG_TRACE_END(""AirPDcapScanForKeys"");
            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;
        }
    } else {
        AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Skipping: not an EAPOL packet"", AIRPDCAP_DEBUG_LEVEL_3);
    }

    AIRPDCAP_DEBUG_TRACE_END(""AirPDcapScanForKeys"");
    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
}
",agree
CVE-2018-6111," void StorageHandler::GetUsageAndQuota(
     const String& origin,
     std::unique_ptr<GetUsageAndQuotaCallback> callback) {
  if (!process_)
     return callback->sendFailure(Response::InternalError());
 
   GURL origin_url(origin);
  if (!origin_url.is_valid()) {
    return callback->sendFailure(
         Response::Error(origin + "" is not a valid URL""));
   }
 
  storage::QuotaManager* manager =
      process_->GetStoragePartition()->GetQuotaManager();
   BrowserThread::PostTask(
       BrowserThread::IO, FROM_HERE,
       base::BindOnce(&GetUsageAndQuotaOnIOThread, base::RetainedRef(manager),
                      origin_url, base::Passed(std::move(callback))));
 }
",agree
CVE-2016-2414,"bool CmapCoverage::getCoverage(SparseBitSet& coverage, const uint8_t* cmap_data, size_t cmap_size) {
 vector<uint32_t> coverageVec;
 const size_t kHeaderSize = 4;
 const size_t kNumTablesOffset = 2;
 const size_t kTableSize = 8;

     const size_t kPlatformIdOffset = 0;
     const size_t kEncodingIdOffset = 2;
     const size_t kOffsetOffset = 4;
    const int kMicrosoftPlatformId = 3;
    const int kUnicodeBmpEncodingId = 1;
    const int kUnicodeUcs4EncodingId = 10;
     if (kHeaderSize > cmap_size) {
         return false;
     }
    int numTables = readU16(cmap_data, kNumTablesOffset);
     if (kHeaderSize + numTables * kTableSize > cmap_size) {
         return false;
     }
    int bestTable = -1;
    for (int i = 0; i < numTables; i++) {
         uint16_t platformId = readU16(cmap_data, kHeaderSize + i * kTableSize + kPlatformIdOffset);
         uint16_t encodingId = readU16(cmap_data, kHeaderSize + i * kTableSize + kEncodingIdOffset);
         if (platformId == kMicrosoftPlatformId && encodingId == kUnicodeUcs4EncodingId) {
            bestTable = i;
 break;
 } else if (platformId == kMicrosoftPlatformId && encodingId == kUnicodeBmpEncodingId) {
            bestTable = i;
 }
 }

 #ifdef PRINTF_DEBUG
     printf(""best table = %d\n"", bestTable);
 #endif
    if (bestTable < 0) {
         return false;
     }
     uint32_t offset = readU32(cmap_data, kHeaderSize + bestTable * kTableSize + kOffsetOffset);
    if (offset + 2 > cmap_size) {
         return false;
     }
     uint16_t format = readU16(cmap_data, offset);
 bool success = false;
 const uint8_t* tableData = cmap_data + offset;
 const size_t tableSize = cmap_size - offset;
 if (format == 4) {
        success = getCoverageFormat4(coverageVec, tableData, tableSize);
 } else if (format == 12) {
        success = getCoverageFormat12(coverageVec, tableData, tableSize);
 }
 if (success) {
        coverage.initFromRanges(&coverageVec.front(), coverageVec.size() >> 1);
 }
#ifdef PRINTF_DEBUG
 for (int i = 0; i < coverageVec.size(); i += 2) {
        printf(""%x:%x\n"", coverageVec[i], coverageVec[i + 1]);
 }
#endif
 return success;
}
",agree
CVE-2017-13715,"bool __skb_flow_dissect(const struct sk_buff *skb,
			struct flow_dissector *flow_dissector,
			void *target_container,
			void *data, __be16 proto, int nhoff, int hlen)
{
	struct flow_dissector_key_control *key_control;
	struct flow_dissector_key_basic *key_basic;
	struct flow_dissector_key_addrs *key_addrs;
	struct flow_dissector_key_ports *key_ports;
 	struct flow_dissector_key_tags *key_tags;
 	struct flow_dissector_key_keyid *key_keyid;
 	u8 ip_proto = 0;
 
 	if (!data) {
 		data = skb->data;
		proto = skb->protocol;
		nhoff = skb_network_offset(skb);
		hlen = skb_headlen(skb);
	}

	/* It is ensured by skb_flow_dissector_init() that control key will
	 * be always present.
	 */
	key_control = skb_flow_dissector_target(flow_dissector,
						FLOW_DISSECTOR_KEY_CONTROL,
						target_container);

	/* It is ensured by skb_flow_dissector_init() that basic key will
	 * be always present.
	 */
	key_basic = skb_flow_dissector_target(flow_dissector,
					      FLOW_DISSECTOR_KEY_BASIC,
					      target_container);

	if (skb_flow_dissector_uses_key(flow_dissector,
					FLOW_DISSECTOR_KEY_ETH_ADDRS)) {
		struct ethhdr *eth = eth_hdr(skb);
		struct flow_dissector_key_eth_addrs *key_eth_addrs;

		key_eth_addrs = skb_flow_dissector_target(flow_dissector,
							  FLOW_DISSECTOR_KEY_ETH_ADDRS,
							  target_container);
		memcpy(key_eth_addrs, &eth->h_dest, sizeof(*key_eth_addrs));
	}

again:
	switch (proto) {
	case htons(ETH_P_IP): {
		const struct iphdr *iph;
		struct iphdr _iph;
 ip:
 		iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);
 		if (!iph || iph->ihl < 5)
			return false;
 		nhoff += iph->ihl * 4;
 
 		ip_proto = iph->protocol;
		if (ip_is_fragment(iph))
			ip_proto = 0;

		if (!skb_flow_dissector_uses_key(flow_dissector,
						 FLOW_DISSECTOR_KEY_IPV4_ADDRS))
			break;

		key_addrs = skb_flow_dissector_target(flow_dissector,
			      FLOW_DISSECTOR_KEY_IPV4_ADDRS, target_container);
		memcpy(&key_addrs->v4addrs, &iph->saddr,
		       sizeof(key_addrs->v4addrs));
		key_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;
		break;
	}
	case htons(ETH_P_IPV6): {
		const struct ipv6hdr *iph;
		struct ipv6hdr _iph;
		__be32 flow_label;

 ipv6:
 		iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);
 		if (!iph)
			return false;
 
 		ip_proto = iph->nexthdr;
 		nhoff += sizeof(struct ipv6hdr);

		if (skb_flow_dissector_uses_key(flow_dissector,
						FLOW_DISSECTOR_KEY_IPV6_ADDRS)) {
			struct flow_dissector_key_ipv6_addrs *key_ipv6_addrs;

			key_ipv6_addrs = skb_flow_dissector_target(flow_dissector,
								   FLOW_DISSECTOR_KEY_IPV6_ADDRS,
								   target_container);

			memcpy(key_ipv6_addrs, &iph->saddr, sizeof(*key_ipv6_addrs));
			key_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;
		}

		flow_label = ip6_flowlabel(iph);
		if (flow_label) {
			if (skb_flow_dissector_uses_key(flow_dissector,
				FLOW_DISSECTOR_KEY_FLOW_LABEL)) {
				key_tags = skb_flow_dissector_target(flow_dissector,
								     FLOW_DISSECTOR_KEY_FLOW_LABEL,
								     target_container);
				key_tags->flow_label = ntohl(flow_label);
			}
		}

		break;
	}
	case htons(ETH_P_8021AD):
	case htons(ETH_P_8021Q): {
		const struct vlan_hdr *vlan;
		struct vlan_hdr _vlan;
 
 		vlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);
 		if (!vlan)
			return false;
 
 		if (skb_flow_dissector_uses_key(flow_dissector,
 						FLOW_DISSECTOR_KEY_VLANID)) {
			key_tags = skb_flow_dissector_target(flow_dissector,
							     FLOW_DISSECTOR_KEY_VLANID,
							     target_container);

			key_tags->vlan_id = skb_vlan_tag_get_id(skb);
		}

		proto = vlan->h_vlan_encapsulated_proto;
		nhoff += sizeof(*vlan);
		goto again;
	}
	case htons(ETH_P_PPP_SES): {
		struct {
			struct pppoe_hdr hdr;
			__be16 proto;
 		} *hdr, _hdr;
 		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);
 		if (!hdr)
			return false;
 		proto = hdr->proto;
 		nhoff += PPPOE_SES_HLEN;
 		switch (proto) {
		case htons(PPP_IP):
			goto ip;
 		case htons(PPP_IPV6):
 			goto ipv6;
 		default:
			return false;
 		}
 	}
 	case htons(ETH_P_TIPC): {
		struct {
			__be32 pre[3];
			__be32 srcnode;
 		} *hdr, _hdr;
 		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);
 		if (!hdr)
			return false;
		key_basic->n_proto = proto;
		key_control->thoff = (u16)nhoff;
 
 		if (skb_flow_dissector_uses_key(flow_dissector,
 						FLOW_DISSECTOR_KEY_TIPC_ADDRS)) {
			key_addrs = skb_flow_dissector_target(flow_dissector,
							      FLOW_DISSECTOR_KEY_TIPC_ADDRS,
							      target_container);
 			key_addrs->tipcaddrs.srcnode = hdr->srcnode;
 			key_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;
 		}
		return true;
 	}
 
 	case htons(ETH_P_MPLS_UC):
	case htons(ETH_P_MPLS_MC): {
		struct mpls_label *hdr, _hdr[2];
mpls:
 		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,
 					   hlen, &_hdr);
 		if (!hdr)
			return false;
 
 		if ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>
 		     MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {
			if (skb_flow_dissector_uses_key(flow_dissector,
							FLOW_DISSECTOR_KEY_MPLS_ENTROPY)) {
				key_keyid = skb_flow_dissector_target(flow_dissector,
								      FLOW_DISSECTOR_KEY_MPLS_ENTROPY,
								      target_container);
				key_keyid->keyid = hdr[1].entry &
 					htonl(MPLS_LS_LABEL_MASK);
 			}
 
			key_basic->n_proto = proto;
			key_basic->ip_proto = ip_proto;
			key_control->thoff = (u16)nhoff;
			return true;
 		}
 
		return true;
 	}
 
 	case htons(ETH_P_FCOE):
 		key_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);
 		/* fall through */
 	default:
		return false;
 	}
 
 ip_proto_again:
	switch (ip_proto) {
	case IPPROTO_GRE: {
		struct gre_hdr {
			__be16 flags;
			__be16 proto;
		} *hdr, _hdr;
 
 		hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);
 		if (!hdr)
			return false;
 		/*
 		 * Only look inside GRE if version zero and no
 		 * routing
		 */
		if (hdr->flags & (GRE_VERSION | GRE_ROUTING))
			break;

		proto = hdr->proto;
		nhoff += 4;
		if (hdr->flags & GRE_CSUM)
			nhoff += 4;
		if (hdr->flags & GRE_KEY) {
			const __be32 *keyid;
			__be32 _keyid;

			keyid = __skb_header_pointer(skb, nhoff, sizeof(_keyid),
 						     data, hlen, &_keyid);
 
 			if (!keyid)
				return false;
 
 			if (skb_flow_dissector_uses_key(flow_dissector,
 							FLOW_DISSECTOR_KEY_GRE_KEYID)) {
				key_keyid = skb_flow_dissector_target(flow_dissector,
								      FLOW_DISSECTOR_KEY_GRE_KEYID,
								      target_container);
				key_keyid->keyid = *keyid;
			}
			nhoff += 4;
		}
		if (hdr->flags & GRE_SEQ)
			nhoff += 4;
		if (proto == htons(ETH_P_TEB)) {
			const struct ethhdr *eth;
			struct ethhdr _eth;

			eth = __skb_header_pointer(skb, nhoff,
 						   sizeof(_eth),
 						   data, hlen, &_eth);
 			if (!eth)
				return false;
 			proto = eth->h_proto;
 			nhoff += sizeof(*eth);
 		}
		goto again;
	}
	case NEXTHDR_HOP:
	case NEXTHDR_ROUTING:
	case NEXTHDR_DEST: {
		u8 _opthdr[2], *opthdr;

		if (proto != htons(ETH_P_IPV6))
			break;

 		opthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),
 					      data, hlen, &_opthdr);
 		if (!opthdr)
			return false;
 
 		ip_proto = opthdr[0];
 		nhoff += (opthdr[1] + 1) << 3;

		goto ip_proto_again;
	}
	case IPPROTO_IPIP:
		proto = htons(ETH_P_IP);
		goto ip;
	case IPPROTO_IPV6:
		proto = htons(ETH_P_IPV6);
		goto ipv6;
	case IPPROTO_MPLS:
		proto = htons(ETH_P_MPLS_UC);
		goto mpls;
	default:
 		break;
 	}
 
	key_basic->n_proto = proto;
	key_basic->ip_proto = ip_proto;
	key_control->thoff = (u16)nhoff;
 	if (skb_flow_dissector_uses_key(flow_dissector,
 					FLOW_DISSECTOR_KEY_PORTS)) {
 		key_ports = skb_flow_dissector_target(flow_dissector,
						      FLOW_DISSECTOR_KEY_PORTS,
						      target_container);
		key_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,
 							data, hlen);
 	}
 
	return true;
 }
",agree
CVE-2011-2350,"EncodedJSValue JSC_HOST_CALL jsTestInterfacePrototypeFunctionSupplementalMethod2(ExecState* exec)
{
    JSValue thisValue = exec->hostThisValue();
    if (!thisValue.inherits(&JSTestInterface::s_info))
        return throwVMTypeError(exec);
    JSTestInterface* castedThis = jsCast<JSTestInterface*>(asObject(thisValue));
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestInterface::s_info);
     TestInterface* impl = static_cast<TestInterface*>(castedThis->impl());
     if (exec->argumentCount() < 2)
        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
     ExceptionCode ec = 0;
     ScriptExecutionContext* scriptContext = jsCast<JSDOMGlobalObject*>(exec->lexicalGlobalObject())->scriptExecutionContext();
     if (!scriptContext)
        return JSValue::encode(jsUndefined());
    const String& strArg(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));
    if (exec->hadException())
        return JSValue::encode(jsUndefined());
    TestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined)));
    if (exec->hadException())
        return JSValue::encode(jsUndefined());

    JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(TestSupplemental::supplementalMethod2(impl, scriptContext, strArg, objArg, ec)));
    setDOMException(exec, ec);
    return JSValue::encode(result);
}
",neutral
CVE-2018-1000040,"void fz_init_cached_color_converter(fz_context *ctx, fz_color_converter *cc, fz_colorspace *is, fz_colorspace *ds, fz_colorspace *ss, const fz_color_params *params)
{
	int n = ss->n;
	fz_cached_color_converter *cached = fz_malloc_struct(ctx, fz_cached_color_converter);

	cc->opaque = cached;
	cc->convert = fz_cached_color_convert;
	cc->ds = ds ? ds : fz_device_gray(ctx);
	cc->ss = ss;
	cc->is = is;

	fz_try(ctx)
	{
		fz_find_color_converter(ctx, &cached->base, is, cc->ds, ss, params);
		cached->hash = fz_new_hash_table(ctx, 256, n * sizeof(float), -1, fz_free);
	}
	fz_catch(ctx)
	{
                fz_drop_color_converter(ctx, &cached->base);
                fz_drop_hash_table(ctx, cached->hash);
                fz_free(ctx, cached);
                fz_rethrow(ctx);
        }
 }
",agree
CVE-2013-0911,"void DatabaseMessageFilter::OnDatabaseOpened(const string16& origin_identifier,
                                             const string16& database_name,
                                              const string16& description,
                                              int64 estimated_size) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));
   int64 database_size = 0;
   db_tracker_->DatabaseOpened(origin_identifier, database_name, description,
                               estimated_size, &database_size);
  database_connections_.AddConnection(origin_identifier, database_name);
  Send(new DatabaseMsg_UpdateSize(origin_identifier, database_name,
                                  database_size));
}
",agree
CVE-2016-5170,"void Document::UnregisterNodeListWithIdNameCache(const LiveNodeListBase* list) {
  node_lists_.Remove(list, kInvalidateOnIdNameAttrChange);
}
",neutral
CVE-2018-6031,"pp::Buffer_Dev PDFiumEngine::GetFlattenedPrintData(FPDF_DOCUMENT doc) {
  pp::Buffer_Dev buffer;
  ScopedSubstFont scoped_subst_font(this);
  int page_count = FPDF_GetPageCount(doc);
  for (int i = 0; i < page_count; ++i) {
    FPDF_PAGE page = FPDF_LoadPage(doc, i);
    DCHECK(page);
    int flatten_ret = FPDFPage_Flatten(page, FLAT_PRINT);
    FPDF_ClosePage(page);
    if (flatten_ret == FLATTEN_FAIL)
      return buffer;
  }

  PDFiumMemBufferFileWrite output_file_write;
  if (FPDF_SaveAsCopy(doc, &output_file_write, 0)) {
    size_t size = output_file_write.size();
    buffer = pp::Buffer_Dev(client_->GetPluginInstance(), size);
    if (!buffer.is_null())
      memcpy(buffer.data(), output_file_write.buffer().c_str(), size);
  }
  return buffer;
}
",disagree
CVE-2016-7151,"static bool valid_rep(cs_struct *h, unsigned int opcode)
{
	unsigned int id;
	int i = insn_find(insns, ARR_SIZE(insns), opcode, &h->insn_cache);
	if (i != 0) {
		id = insns[i].mapid;
		switch(id) {
			default:
				return false;

			case X86_INS_MOVSB:
			case X86_INS_MOVSW:
			case X86_INS_MOVSQ:

			case X86_INS_LODSB:
			case X86_INS_LODSW:
			case X86_INS_LODSQ:

			case X86_INS_STOSB:
			case X86_INS_STOSW:
			case X86_INS_STOSQ:

			case X86_INS_INSB:
			case X86_INS_INSW:
			case X86_INS_INSD:

			case X86_INS_OUTSB:
			case X86_INS_OUTSW:
			case X86_INS_OUTSD:
				return true;

			case X86_INS_MOVSD:
				if (opcode == X86_MOVSL) // REP MOVSD
					return true;
				return false;

			case X86_INS_LODSD:
				if (opcode == X86_LODSL) // REP LODSD
					return true;
				return false;

			case X86_INS_STOSD:
				if (opcode == X86_STOSL) // REP STOSD
					return true;
				return false;
		}
	}

	return false;
}
",neutral
CVE-2011-2839,"  scoped_refptr<Extension> LoadExtensionWithLocation(
      DictionaryValue* value,
      Extension::Location location,
      bool strict_error_checks,
      std::string* error) {
    FilePath path;
    PathService::Get(chrome::DIR_TEST_DATA, &path);
    path = path.AppendASCII(""extensions"").AppendASCII(""manifest_tests"");
    int flags = Extension::NO_FLAGS;
    if (strict_error_checks)
      flags |= Extension::STRICT_ERROR_CHECKS;
    return Extension::Create(path.DirName(), location, *value, flags, error);
  }
",agree
CVE-2016-5185,"void AutofillPopupViewViews::AddExtraInitParams(
    views::Widget::InitParams* params) {}
",disagree
CVE-2016-10197,"evdns_base_resolv_conf_parse_impl(struct evdns_base *base, int flags, const char *const filename) {
	size_t n;
	char *resolv;
	char *start;
	int err = 0;

	log(EVDNS_LOG_DEBUG, ""Parsing resolv.conf file %s"", filename);

	if (flags & DNS_OPTION_HOSTSFILE) {
		char *fname = evdns_get_default_hosts_filename();
		evdns_base_load_hosts(base, fname);
		if (fname)
			mm_free(fname);
	}

	if ((err = evutil_read_file_(filename, &resolv, &n, 0)) < 0) {
		if (err == -1) {
			/* No file. */
			evdns_resolv_set_defaults(base, flags);
			return 1;
		} else {
			return 2;
		}
	}

	start = resolv;
	for (;;) {
		char *const newline = strchr(start, '\n');
		if (!newline) {
			resolv_conf_parse_line(base, start, flags);
			break;
		} else {
			*newline = 0;
			resolv_conf_parse_line(base, start, flags);
			start = newline + 1;
		}
	}

	if (!base->server_head && (flags & DNS_OPTION_NAMESERVERS)) {
		/* no nameservers were configured. */
		evdns_base_nameserver_ip_add(base, ""127.0.0.1"");
		err = 6;
	}
	if (flags & DNS_OPTION_SEARCH && (!base->global_search_state || base->global_search_state->num_domains == 0)) {
		search_set_from_hostname(base);
	}

	mm_free(resolv);
	return err;
}
",agree
CVE-2017-12187,"PanoramiXRenderReset(void)
{
    int i;

    for (i = 0; i < RenderNumberRequests; i++)
        ProcRenderVector[i] = PanoramiXSaveRenderVector[i];
    RenderErrBase = 0;
}
",disagree
CVE-2016-5187,"  explicit CallbackOwner(bool* deleted) {
    callback_ = BindRepeating(&CallbackOwner::Unused, WrapRefCounted(this));
    deleted_ = deleted;
  }
",disagree
CVE-2015-8935,"SAPI_API char *sapi_get_default_content_type(TSRMLS_D)
{
	uint len;

	return get_default_content_type(0, &len TSRMLS_CC);
}
",disagree
CVE-2012-6647,"futex_wake(u32 __user *uaddr, unsigned int flags, int nr_wake, u32 bitset)
{
	struct futex_hash_bucket *hb;
	struct futex_q *this, *next;
	struct plist_head *head;
	union futex_key key = FUTEX_KEY_INIT;
	int ret;

	if (!bitset)
		return -EINVAL;

	ret = get_futex_key(uaddr, flags & FLAGS_SHARED, &key, VERIFY_READ);
	if (unlikely(ret != 0))
		goto out;

	hb = hash_futex(&key);
	spin_lock(&hb->lock);
	head = &hb->chain;

	plist_for_each_entry_safe(this, next, head, list) {
		if (match_futex (&this->key, &key)) {
			if (this->pi_state || this->rt_waiter) {
				ret = -EINVAL;
				break;
			}

			/* Check if one of the bits is set in both bitsets */
			if (!(this->bitset & bitset))
				continue;

			wake_futex(this);
			if (++ret >= nr_wake)
				break;
		}
	}

	spin_unlock(&hb->lock);
	put_futex_key(&key);
out:
	return ret;
}
",disagree
CVE-2017-5032,"ClientControlledShellSurface::CreateNonClientFrameView(views::Widget* widget) {
  ash::wm::WindowState* window_state = GetWindowState();
  std::unique_ptr<ash::wm::ClientControlledState::Delegate> delegate =
      GetFactoryForTesting()
          ? GetFactoryForTesting().Run()
          : std::make_unique<ClientControlledStateDelegate>(this);

  auto window_delegate = std::make_unique<ClientControlledWindowStateDelegate>(
      this, delegate.get());
  auto state =
      std::make_unique<ash::wm::ClientControlledState>(std::move(delegate));
  client_controlled_state_ = state.get();
  window_state->SetStateObject(std::move(state));
  window_state->SetDelegate(std::move(window_delegate));
  ash::NonClientFrameViewAsh* frame_view =
      static_cast<ash::NonClientFrameViewAsh*>(
          CreateNonClientFrameViewInternal(widget, /*client_controlled=*/true));
  immersive_fullscreen_controller_ =
      std::make_unique<ash::ImmersiveFullscreenController>();
  frame_view->InitImmersiveFullscreenControllerForView(
      immersive_fullscreen_controller_.get());
  return frame_view;
}
",disagree
CVE-2017-9739,"  static void  Move_Zp2_Point( EXEC_OPS
                               Long        point,
                               TT_F26Dot6  dx,
                               TT_F26Dot6  dy,
                               Bool        touch )
  {
    if ( CUR.GS.freeVector.x != 0 )
    {
      CUR.zp2.cur_x[point] += dx;
      if ( touch )
        CUR.zp2.touch[point] |= TT_Flag_Touched_X;
    }

    if ( CUR.GS.freeVector.y != 0 )
    {
      CUR.zp2.cur_y[point] += dy;
      if ( touch )
        CUR.zp2.touch[point] |= TT_Flag_Touched_Y;
    }
  }
",disagree
CVE-2016-7969,"static ASS_Image *my_draw_bitmap(unsigned char *bitmap, int bitmap_w,
                                 int bitmap_h, int stride, int dst_x,
                                 int dst_y, uint32_t color,
                                 CompositeHashValue *source)
{
    ASS_ImagePriv *img = malloc(sizeof(ASS_ImagePriv));
    if (!img) {
        if (!source)
            ass_aligned_free(bitmap);
        return NULL;
    }

    img->result.w = bitmap_w;
    img->result.h = bitmap_h;
    img->result.stride = stride;
    img->result.bitmap = bitmap;
    img->result.color = color;
    img->result.dst_x = dst_x;
    img->result.dst_y = dst_y;

    img->source = source;
    ass_cache_inc_ref(source);
    img->ref_count = 0;

    return &img->result;
}
",agree
